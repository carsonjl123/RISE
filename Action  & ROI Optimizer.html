<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>RISE • Control Model — CM1 Visuals v3u (no-baseline ROI)</title>
<style>
  :root{
    --bg:#0b1b2b; --panel:#0e2236; --panel-deeper:#0b1f31; --text:#dbe6f5; --muted:#9fb3c9;
    --cyan:#22d3ee; --green:#34d399; --lav:#a78bfa; --magenta:#ff4dff; --amber:#ffb84d;
    --chip:#10283f; --chip-border:#1a3a54; --row:#0c2133; --row-alt:#0b1d2e;
  }
  *{box-sizing:border-box}
  body{margin:0;background:radial-gradient(1200px 800px at 20% -10%, #143654 0%, #0b1b2b 45%, #081625 100%);color:var(--text);
       font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;line-height:1.2;}
  .container{max-width:1350px;margin:28px auto;padding:0 16px}
  .kpis{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .kpi{background:var(--panel);border:1px solid #143652;padding:14px 16px;border-radius:12px;box-shadow:inset 0 0 0 1px rgba(255,255,255,.02)}
  .kpi h5{margin:0 0 6px 0;font-weight:600;color:var(--muted);font-size:12px;letter-spacing:.4px}
  .kpi .value{font-size:20px;font-weight:800;letter-spacing:.3px}

  .finRow{display:grid;grid-template-columns:repeat(5,minmax(220px,1fr));gap:12px;margin-top:12px}
  .fin{background:linear-gradient(180deg,#0f243a,#0c1f33);border:1px solid #163a59;border-radius:12px;padding:14px 16px;box-shadow:inset 0 0 0 1px rgba(255,255,255,.02)}
  .fin h5{margin:0 0 8px 0;font-size:12px;letter-spacing:.35px;color:#a6c2db}
  .fin .val{font-size:28px;font-weight:900;letter-spacing:.4px}
  .fin small{display:block;color:#90aeca;margin-top:6px}

  .row3grid{display:grid;grid-template-columns:repeat(3,minmax(280px,1fr));gap:16px;align-items:stretch;margin-top:14px}
  @media (max-width:1100px){.row3grid{grid-template-columns:repeat(2,minmax(280px,1fr));}}
  @media (max-width:740px){.row3grid{grid-template-columns:1fr}.finRow{grid-template-columns:1fr}}

  .viz-tile{background:radial-gradient(160% 140% at 0% 0%, rgba(34,211,238,.08), rgba(0,0,0,0)),var(--panel);
    border:1px solid #174361;border-radius:14px;padding:14px 16px;position:relative;min-height:170px;
    box-shadow:0 10px 28px rgba(0,0,0,.22), inset 0 0 0 1px rgba(255,255,255,.02)}
  .viz-tile h5{margin:0 0 8px 0;color:#a9c6df;font-size:12px;letter-spacing:.35px}
  .viz-sub{font-size:12px;opacity:.85;margin-top:8px}
  .sub-badge{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;border:1px solid #1a6f57;background:rgba(52,211,153,.1);color:#34d399;font-size:11px}
  canvas{display:block;margin:0 auto}

  .crrBig{font-size:36px;font-weight:900;color:var(--green);letter-spacing:.4px}
  .crrRow{display:flex;align-items:flex-end;justify-content:space-between;gap:8px}

  .grid{display:grid;grid-template-columns:2.1fr 1fr;gap:12px;margin-top:16px}
  .table-card{background:var(--panel);border:1px solid #143652;border-radius:12px;padding:0;overflow:hidden}
  .table-head,.row{display:grid;grid-template-columns:1.1fr 1.2fr .9fr 1fr .8fr .8fr .6fr;gap:8px;padding:12px 14px;align-items:center}
  .table-head{background:linear-gradient(180deg,#10263d,#0d2236);color:var(--muted);font-size:12px;letter-spacing:.35px;border-bottom:1px solid #143652;position:sticky;top:0;z-index:1}
  .rows{max-height:520px;overflow:auto;background:linear-gradient(180deg,var(--row),var(--row-alt))}
  .chip{background:var(--chip);border:1px solid var(--chip-border);color:var(--muted);font-size:12px;padding:6px 10px;border-radius:999px;display:inline-flex;gap:6px;width:max-content}
  .toggle{--w:48px;--h:26px;width:var(--w);height:var(--h);border-radius:999px;background:#0c2941;border:1px solid #123a59;position:relative;cursor:pointer}
  .toggle i{position:absolute;top:3px;left:3px;width:20px;height:20px;border-radius:50%;background:#7f8ea3;transition:all .22s;box-shadow:inset 0 -2px 4px rgba(0,0,0,.45)}
  .toggle.on{background:rgba(34,211,238,.18);box-shadow:0 0 16px rgba(34,211,238,.55),0 0 32px rgba(34,211,238,.25);border-color:#1b6b7c}
  .toggle.on i{left:25px;background:#22d3ee;box-shadow:0 0 10px rgba(34,211,238,.75)}

  .right-col{display:flex;flex-direction:column;gap:12px}
  .lights-card{background:var(--panel);border:1px solid #143652;border-radius:12px;padding:14px 16px}
  .lights-title{display:grid;grid-template-columns:auto 1fr;align-items:center;margin-bottom:10px;column-gap:10px}
  .lights-title h5{margin:0;text-align:center;font-size:14px;letter-spacing:.45px;font-weight:800;
    background:linear-gradient(90deg,var(--cyan),var(--green));-webkit-background-clip:text;background-clip:text;color:transparent;text-shadow:0 0 12px rgba(34,211,238,.2)}
  .lamps{display:grid;grid-template-columns:repeat(5,1fr);gap:12px;padding:8px 2px 6px 2px}
  .lamp{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;background:var(--panel-deeper);border:1px solid #153a58;border-radius:12px;padding:20px 8px 14px;height:92px}
  .dot{width:14px;height:14px;border-radius:50%;background:#132c42;border:2px solid #1a3b5c;box-shadow:inset 0 0 0 2px rgba(0,0,0,.3)}
  .dot.on{background:#22d3ee;box-shadow:0 0 16px rgba(34,211,238,.55),0 0 32px rgba(34,211,238,.25);border-color:#1c7082}
  .lamp-label{text-align:center;margin-top:8px;font-size:12px;color:var(--muted)}
  .lamp-tip{position:absolute;bottom:8px;right:8px;font-size:11px;color:#78e7f5;opacity:.75}

  .assist{background:var(--panel);border:1px solid #143652;border-radius:12px;padding:14px 16px}
  .assist h5{margin:0 0 10px;color:var(--muted);letter-spacing:.35px}
  .pill{display:inline-flex;gap:8px;align-items:flex-start;padding:10px 12px;border-radius:10px;border:1px solid #174361;background:linear-gradient(180deg,#0f2942,#0d243a);margin-bottom:8px;font-size:13px}
  .pill .tag{font-size:11px;font-weight:700;letter-spacing:.4px;padding:3px 8px;border-radius:999px;margin-top:2px}
  .tag-rec{background:rgba(34,211,238,.15);color:#22d3ee;border:1px solid #1b6b7c}
  .tag-prob{background:rgba(52,211,153,.15);color:#34d399;border:1px solid #1a6f57}
  .tag-cost{background:rgba(167,139,250,.15);color:#a78bfa;border:1px solid #5946a5}

  /* === Analytical Assist: glowing terminal screen === */
  .assist{
    background: radial-gradient(120% 180% at 10% 0%, rgba(34,211,238,.08), transparent 45%),
                linear-gradient(180deg,#061723,#0a2234);
    border:1px solid rgba(44,209,240,.45);
    box-shadow: 0 0 24px rgba(44,209,240,.25), inset 0 0 0 1px rgba(255,255,255,.03);
    border-radius: 14px;
    position: relative;
    overflow: hidden;
  }
  .assist::before{ /* subtle scanline */
    content:""; position:absolute; inset:0;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0.027) 0px,
      rgba(255,255,255,0.027) 1px,
      transparent 2px,
      transparent 3px
    );
    pointer-events:none;
    mix-blend-mode: soft-light;
  }
  .assist::after{ /* slow sweep glow */
    content:""; position:absolute; top:-40%; left:-20%; width:60%; height:180%;
    background: radial-gradient(50% 50% at 50% 50%, rgba(44,209,240,.15), transparent 60%);
    transform: rotate(18deg);
    animation: sweep 9s linear infinite;
    pointer-events:none;
  }
  @keyframes sweep{
    0%   { transform: translateX(-40%) rotate(18deg); }
    50%  { transform: translateX(140%) rotate(18deg); }
    100% { transform: translateX(-40%) rotate(18deg); }
  }
  .assist h5{
    margin: 0 0 12px 0;
    color:#bff8ff;
    letter-spacing:.045em;
    text-shadow: 0 0 12px rgba(44,209,240,.45);
  }
  .pill{
    background: linear-gradient(180deg,#092238,#0a283f);
    border-color: rgba(44,209,240,.35);
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.02), 0 6px 18px rgba(0,0,0,.25);
  }


  .actions{display:flex;justify-content:flex-end;padding:12px 16px;border-top:1px solid #143652;background:#0d2134}
  .btn-primary{background:linear-gradient(180deg,#0fdcf4,#18b4c5);color:#00222a;font-weight:800;letter-spacing:.3px;border:none;padding:12px 16px;border-radius:10px;cursor:pointer;
    box-shadow:0 10px 25px rgba(34,211,238,.25),inset 0 0 0 1px rgba(255,255,255,.25)}

  .npv-pos{color:#34d399;text-shadow:0 0 10px rgba(52,211,153,.45),0 0 22px rgba(52,211,153,.25);}
  .npv-neg{color:#ff4dff;text-shadow:0 0 10px rgba(255,77,255,.5),0 0 22px rgba(255,77,255,.3);}
  .npv-neutral{color:#dbe6f5;text-shadow:none;}
  .help-tip{position:absolute;top:12px;right:14px;font-size:12px;color:#9fcde6;opacity:.8}

.roi-pos{ color:#00ff9c; text-shadow:0 0 10px rgba(0,255,156,.6);}.roi-neg{ color:#ff33cc; text-shadow:0 0 10px rgba(255,51,204,.5);}
  /* === Analytical Assist: recessed white screen === */
  .assist{
    background: radial-gradient(140% 180% at 50% 0%, #ffffff 0%, #f7fbff 65%, #f1f6fb 100%);
    border: 1px solid rgba(9,40,66,.18);
    border-radius: 16px;
    position: relative;
    overflow: hidden;
    box-shadow:
      inset 0 1px 0 rgba(255,255,255,.85),
      inset 0 8px 22px rgba(9,40,66,.06),
      inset 0 -8px 16px rgba(9,40,66,.05),
      0 8px 24px rgba(0,0,0,.18);
  }
  .assist::before{ /* subtle scanlines */
    content:"";
    position:absolute; inset:0;
    background:
      repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.04) 29px),
      linear-gradient(180deg, rgba(9,40,66,.06), transparent 28%);
    pointer-events:none;
  }
  .assist::after{ /* gentle sweep glow */
    content:"";
    position:absolute; top:-40%; left:-25%; width:70%; height:190%;
    background: radial-gradient(40% 50% at 50% 50%, rgba(118,255,230,.20), transparent 60%);
    transform: rotate(16deg);
    animation: assistSweep 9s linear infinite;
    pointer-events:none;
    mix-blend-mode: screen;
  }
  @keyframes assistSweep{
    0%   { transform: translateX(-40%) rotate(16deg); }
    50%  { transform: translateX(140%) rotate(16deg); }
    100% { transform: translateX(-40%) rotate(16deg); }
  }
  .assist h5{
    margin: 0 0 12px 0;
    color: #0a2740;
    letter-spacing: .045em;
    text-shadow: 0 0 0 transparent;
  }
  .pill{
    background: linear-gradient(180deg,#f4f8fc,#eef4fa);
    border-color: rgba(9,40,66,.18);
    color:#0b2a44;
    box-shadow: inset 0 0 0 1px rgba(255,255,255,.6);
  }


/* === Analytical Assist: recessed TV glow === */
.assist{
  background: radial-gradient(140% 180% at 50% 0%, #ffffff 0%, #f8fbff 68%, #eef5fb 100%);
  border: 1px solid rgba(9,24,40,.22);
  border-radius: 16px;
  position: relative;
  overflow: hidden;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.95),
    inset 0 10px 28px rgba(9,24,40,.10),
    inset 0 -14px 26px rgba(9,24,40,.08),
    inset 0 0 60px rgba(9,24,40,.10),
    0 0 0 2px rgba(10, 40, 70, .35),
    0 18px 48px rgba(0,0,0,.55),
    0 0 120px rgba(118,255,230,.24);
}
.assist::before{
  content:""; position:absolute; inset:-24px;
  background:
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.06) 45%, rgba(0,0,0,.22) 90%),
    repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.05) 29px);
  pointer-events:none;
  mix-blend-mode: multiply;
}
.assist::after{
  content:""; position:absolute; top:-55%; left:-40%; width:95%; height:235%;
  background: radial-gradient(40% 50% at 50% 50%, rgba(118,255,230,.38), rgba(118,255,230,.20) 40%, transparent 70%);
  transform: rotate(12deg);
  animation: assistSweep 6.5s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.6px);
}
@keyframes assistSweep{
  0%   { transform: translateX(-48%) rotate(12deg); opacity:.6; }
  50%  { transform: translateX(155%) rotate(12deg); opacity:.9; }
  100% { transform: translateX(-48%) rotate(12deg); opacity:.6; }
}
.assist h5{
  margin: 0 0 12px 0;
  color: #082137;
  letter-spacing: .05em;
  text-shadow: 0 1px 0 rgba(255,255,255,.6);
}
.assist-body{
  color:#0a263f;
  text-shadow: 0 1px 0 rgba(255,255,255,.55);
}
.assist-body .line { margin: 9px 0; }


/* === Assist: beveled 3D frame with inner shadows + soft outer glow === */
.assist{
  border-radius: 18px;
  border: 1px solid #dfe8f2;
  background-clip: padding-box;
  /* Stacked shadows to simulate bevel (inner) + rim + soft white glow (outer) */
  box-shadow:
    /* inner bevel highlights/shadows */
    inset 0 2px 0 rgba(255,255,255,.95),
    inset 0 -2px 0 rgba(9,24,40,.10),
    inset 2px 0 0 rgba(255,255,255,.60),
    inset -2px 0 0 rgba(9,24,40,.10),
    inset 0 12px 28px rgba(9,24,40,.08),
    inset 0 -14px 26px rgba(9,24,40,.08),
    /* rim accent */
    0 0 0 2px rgba(245,248,253,.85),
    /* soft outside glow */
    0 0 36px rgba(255,255,255,.45),
    0 18px 48px rgba(0,0,0,.55),
    0 0 120px rgba(118,255,230,.22);
}
/* slightly deeper recess at the very edge */
.assist::before{
  content:""; position:absolute; inset:-22px;
  background:
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.06) 45%, rgba(0,0,0,.20) 92%),
    repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.05) 29px);
  pointer-events:none;
  mix-blend-mode: multiply;
  border-radius: 22px;
}
/* brighter, longer sweep for 'TV' feel */
.assist::after{
  content:""; position:absolute; top:-60%; left:-45%; width:110%; height:250%;
  background: radial-gradient(40% 50% at 50% 50%, rgba(118,255,230,.42), rgba(118,255,230,.22) 40%, transparent 72%);
  transform: rotate(11deg);
  animation: assistSweep 6s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.6px);
  border-radius: 18px;
}


/* === Assist: thicker frame + darker recessed edges === */
.assist{
  border-width: 2px;
  border-color: #d6e1ee;
  box-shadow:
    /* crisper inner bevel */
    inset 0 2px 0 rgba(255,255,255,.96),
    inset 0 -3px 0 rgba(9,24,40,.18),
    inset 3px 0 0 rgba(255,255,255,.65),
    inset -3px 0 0 rgba(9,24,40,.18),
    /* deeper recess glows */
    inset 0 18px 36px rgba(9,24,40,.14),
    inset 0 -22px 40px rgba(9,24,40,.16),
    /* rim + outer halo */
    0 0 0 2px rgba(245,248,253,.90),
    0 0 42px rgba(255,255,255,.55),
    0 22px 58px rgba(0,0,0,.60),
    0 0 140px rgba(118,255,230,.24);
}
.assist::before{
  inset:-26px;
  background:
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.10) 42%, rgba(0,0,0,.28) 92%),
    repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.06) 29px);
  border-radius: 26px;
}


/* === Assist: deeper recess (screen below frame) === */
.assist{
  /* keep bright screen but push it visually inward */
  background: radial-gradient(140% 180% at 50% 0%, #ffffff 0%, #f7fbff 66%, #eaf2f9 100%);
  border: 2px solid #d3deea;
  border-radius: 18px;
  position: relative;
  overflow: hidden;
  /* prioritize inset shadows over outer glow so it reads recessed */
  box-shadow:
    /* strong inner lip (top/light, bottom/dark) */
    inset 0 2px 0 rgba(255,255,255,.95),
    inset 0 -3px 0 rgba(6,20,32,.28),
    inset 3px 0 0 rgba(255,255,255,.70),
    inset -3px 0 0 rgba(6,20,32,.20),
    /* broad inner recess around edges */
    inset 0 24px 46px rgba(6,20,32,.14),
    inset 0 -28px 50px rgba(6,20,32,.18),
    inset 0 0 90px rgba(6,20,32,.12),
    /* subtle rim and very soft external glow (reduced) */
    0 0 0 1px rgba(245,248,253,.75),
    0 6px 18px rgba(0,0,0,.38),
    0 0 60px rgba(118,255,230,.14);
}
/* make the perimeter vignette pull the screen inward instead of outward */
.assist::before{
  content:""; position:absolute; inset:-22px;
  background:
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.12) 44%, rgba(0,0,0,.30) 92%),
    repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.05) 29px);
  pointer-events:none;
  mix-blend-mode: multiply;
  border-radius: 24px;
  /* inner shadow ring to push content down from the frame */
  box-shadow:
    inset 0 14px 28px rgba(0,0,0,.18),
    inset 0 -16px 30px rgba(0,0,0,.18);
}
/* keep sweep but slightly reduce lift so it doesn't look like it's popping out */
.assist::after{
  content:""; position:absolute; top:-58%; left:-42%; width:100%; height:240%;
  background: radial-gradient(40% 50% at 50% 50%, rgba(118,255,230,.34), rgba(118,255,230,.18) 42%, transparent 72%);
  transform: rotate(12deg);
  animation: assistSweep 6.5s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.6px);
  border-radius: 18px;
}


/* === Assist: orthogonal inner shadows + balanced glow (refined) === */
.assist{
  /* Keep light screen; ensure recess without over-darkening */
  background: radial-gradient(140% 180% at 50% 0%, #ffffff 0%, #f9fbfe 68%, #edf3f9 100%);
  border: 2px solid #d5e0ec;
  border-radius: 18px;
  position: relative;
  overflow: hidden;
  /* Directional inner shadows (orthogonal), lighter values to avoid muddy look */
  box-shadow:
    /* top highlight lip */
    inset 0 2px 0 rgba(255,255,255,.96),
    /* bottom shadow lip */
    inset 0 -2px 0 rgba(11,25,40,.20),
    /* left highlight lip */
    inset 2px 0 0 rgba(255,255,255,.70),
    /* right shadow lip */
    inset -2px 0 0 rgba(11,25,40,.18),
    /* soft corner wells (reduced opacity/radius) */
    inset 0 14px 28px rgba(11,25,40,.10),
    inset 0 -16px 30px rgba(11,25,40,.12),
    inset 16px 0 28px rgba(11,25,40,.08),
    inset -16px 0 28px rgba(11,25,40,.08),
    /* subtle rim and restored outer halo */
    0 0 0 1px rgba(245,248,253,.80),
    0 0 42px rgba(255,255,255,.50),
    0 16px 40px rgba(0,0,0,.45),
    0 0 120px rgba(118,255,230,.18);
}
/* Perimeter vignette: reduce darkness; add orthogonal inner gradient to hint frame depth */
.assist::before{
  content:""; position:absolute; inset:-20px;
  background:
    linear-gradient(to bottom, rgba(0,0,0,.10), rgba(0,0,0,0) 28%),
    linear-gradient(to top, rgba(0,0,0,.12), rgba(0,0,0,0) 30%),
    linear-gradient(to right, rgba(0,0,0,.10), rgba(0,0,0,0) 30%),
    linear-gradient(to left, rgba(0,0,0,.10), rgba(0,0,0,0) 30%),
    repeating-linear-gradient(transparent, transparent 28px, rgba(9,40,66,0.04) 29px);
  pointer-events:none;
  mix-blend-mode: multiply;
  border-radius: 24px;
}
/* Sweep glow: slightly brighter but narrower to avoid lifting the surface */
.assist::after{
  content:""; position:absolute; top:-58%; left:-44%; width:95%; height:235%;
  background: radial-gradient(38% 48% at 50% 50%, rgba(118,255,230,.36), rgba(118,255,230,.18) 40%, transparent 70%);
  transform: rotate(12deg);
  animation: assistSweep 6.8s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.5px);
  border-radius: 18px;
}


/* === Assist: dark brushed-metal frame === */
.assist{
  border: 2px solid #394957;              /* darker steel rim */
  border-radius: 18px;
  /* layered shadows: steel rim + depth, keeping recess feel */
  box-shadow:
    /* crisp inner lip */
    inset 0 2px 0 rgba(255,255,255,.92),
    inset 0 -2px 0 rgba(12,22,32,.28),
    inset 2px 0 0 rgba(255,255,255,.68),
    inset -2px 0 0 rgba(12,22,32,.22),
    /* subtle inner wells */
    inset 0 14px 28px rgba(10,20,30,.12),
    inset 0 -16px 30px rgba(10,20,30,.14),
    inset 16px 0 28px rgba(10,20,30,.08),
    inset -16px 0 28px rgba(10,20,30,.08),
    /* metal rim stack */
    0 0 0 1px #2f3d49,
    0 0 0 3px #40505f,
    0 0 0 6px rgba(34,46,56,.55),
    /* ambient glow */
    0 12px 32px rgba(0,0,0,.55),
    0 0 110px rgba(118,255,230,.16);
}

/* brushed grain along the frame via the perimeter layer */
.assist::before{
  content:""; position:absolute; inset:-20px;
  border-radius: 24px;
  pointer-events:none;
  mix-blend-mode: multiply;
  /* vignette + brushed metal strips */
  background:
    /* soft vignette */
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.10) 46%, rgba(0,0,0,.24) 92%),
    /* horizontal brushing */
    repeating-linear-gradient(90deg, rgba(255,255,255,.02) 0px, rgba(255,255,255,.02) 1px, rgba(0,0,0,.02) 2px, rgba(0,0,0,.02) 3px),
    /* vertical brushing */
    repeating-linear-gradient(0deg, rgba(255,255,255,.01) 0px, rgba(255,255,255,.01) 1px, rgba(0,0,0,.015) 2px, rgba(0,0,0,.015) 3px);
}

/* keep sweep glow but don't overpower the frame */
.assist::after{
  content:""; position:absolute; top:-58%; left:-44%; width:95%; height:235%;
  background: radial-gradient(38% 48% at 50% 50%, rgba(118,255,230,.34), rgba(118,255,230,.16) 40%, transparent 70%);
  transform: rotate(12deg);
  animation: assistSweep 6.8s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.5px);
  border-radius: 18px;
}


/* === Assist: brushed-metal BORDER ring, bright recessed SCREEN === */
.assist{
  border: 12px solid transparent;
  border-radius: 22px;
  position: relative;
  overflow: hidden;
  background:
    radial-gradient(140% 180% at 50% 0%, #ffffff 0%, #f9fbfe 68%, #edf3f9 100%) padding-box,
    linear-gradient(180deg, rgba(20,30,40,.95), rgba(20,30,40,1)) border-box;
  background-clip: padding-box, border-box;
  box-shadow:
    inset 0 2px 0 rgba(255,255,255,.96),
    inset 0 -2px 0 rgba(11,25,40,.20),
    inset 2px 0 0 rgba(255,255,255,.70),
    inset -2px 0 0 rgba(11,25,40,.18),
    inset 0 14px 28px rgba(11,25,40,.10),
    inset 0 -16px 30px rgba(11,25,40,.12),
    inset 16px 0 28px rgba(11,25,40,.08),
    inset -16px 0 28px rgba(11,25,40,.08),
    0 0 0 1px #2f3d49,
    0 0 0 3px #40505f,
    0 0 0 6px rgba(34,46,56,.50),
    0 12px 32px rgba(0,0,0,.50),
    0 0 110px rgba(118,255,230,.16);
}
.assist::before{
  content:"";
  position:absolute;
  inset: -2px;
  border-radius: 24px;
  pointer-events:none;
  -webkit-mask: radial-gradient(closest-side, transparent calc(100% - 12px), black calc(100% - 11px));
  mask: radial-gradient(closest-side, transparent calc(100% - 12px), black calc(100% - 11px));
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,.05) 0px, rgba(255,255,255,.05) 1px, rgba(0,0,0,.06) 2px, rgba(0,0,0,.06) 3px),
    repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0px, rgba(255,255,255,.02) 1px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 3px),
    radial-gradient(120% 120% at 50% 0%, rgba(0,0,0,0) 0%, rgba(0,0,0,.12) 46%, rgba(0,0,0,.24) 92%);
  mix-blend-mode: multiply;
}
.assist::after{
  content:""; position:absolute; top:-58%; left:-44%; width:95%; height:235%;
  background: radial-gradient(38% 48% at 50% 50%, rgba(118,255,230,.34), rgba(118,255,230,.16) 40%, transparent 70%);
  transform: rotate(12deg);
  animation: assistSweep 6.8s linear infinite;
  pointer-events:none;
  mix-blend-mode: screen;
  filter: blur(0.5px);
  border-radius: 18px;
}


/* === Assist: strip screen shadows/glow for a clean flat white surface === */
.assist{
  /* keep brushed-metal border via border-clip setup from v3h, but flatten the screen */
  background:
    /* flat white screen */
    linear-gradient(#ffffff, #ffffff) padding-box,
    /* existing metal frame */
    linear-gradient(180deg, rgba(20,30,40,.95), rgba(20,30,40,1)) border-box !important;
  background-clip: padding-box, border-box;
  /* remove inset and outer shadows to avoid circular artifacts */
  box-shadow: none !important;
}
/* disable vignette/brushed overlays and sweep glow inside the screen */
.assist::before,
.assist::after{
  content: none !important;
  display: none !important;
}


/* === Assist: 3D beveled metal frame + top-right inner-corner shadow === */
.assist{
  /* keep flat white screen + brushed border from prior build */
  background:
    linear-gradient(#ffffff, #ffffff) padding-box,
    linear-gradient(180deg, rgba(20,30,40,.95), rgba(20,30,40,1)) border-box;
  background-clip: padding-box, border-box;
  border: 12px solid transparent;
  border-radius: 22px;
  position: relative;
  overflow: hidden;
  /* restore a tasteful 3D bevel on the frame */
  box-shadow:
    /* outer metal rim depth */
    0 0 0 1px #2f3d49 !important,
    0 0 0 3px #40505f !important,
    0 0 0 6px rgba(34,46,56,.50) !important,
    /* soft ambient */
    0 14px 36px rgba(0,0,0,.50) !important;
}

/* Re-introduce a brushed grain in the frame only (keeps screen flat) */
.assist::before{
  content:"" !important;
  position:absolute;
  inset: -2px;
  border-radius: 24px;
  pointer-events:none;
  /* Mask so grain appears only in the border ring */
  -webkit-mask: radial-gradient(closest-side, transparent calc(100% - 12px), black calc(100% - 11px));
  mask: radial-gradient(closest-side, transparent calc(100% - 12px), black calc(100% - 11px));
  background:
    repeating-linear-gradient(90deg, rgba(255,255,255,.05) 0px, rgba(255,255,255,.05) 1px, rgba(0,0,0,.06) 2px, rgba(0,0,0,.06) 3px),
    repeating-linear-gradient(0deg, rgba(255,255,255,.02) 0px, rgba(255,255,255,.02) 1px, rgba(0,0,0,.03) 2px, rgba(0,0,0,.03) 3px);
  mix-blend-mode: multiply;
}

/* Subtle inner-corner shadow at the top-right INSIDE the border */
.assist::after{
  content:"" !important;
  position:absolute;
  pointer-events:none;
  border-radius: 16px;
  /* place a small radial fade at the top-right inner edge */
  inset: 8px 8px auto auto;  /* top/right inset, no bottom */
  width: 140px; height: 90px;
  background: radial-gradient(120px 80px at 100% 0%, rgba(0,0,0,.12), rgba(0,0,0,.06) 55%, transparent 75%);
  /* keep it very soft so it reads as a bevel lip, not a blob */
  filter: blur(0.3px);
  opacity: .9;
}


/* === Assist: inner shadow at upper-right + outer shadow at bottom-left === */
.assist{
  /* keep existing 3D bevel and rim, add directional outer drop shadow to bottom-left */
  box-shadow:
    0 0 0 1px #2f3d49 !important,
    0 0 0 3px #40505f !important,
    0 0 0 6px rgba(34,46,56,.50) !important,
    /* new bottom-left external shadow */
    -20px 28px 46px rgba(0,0,0,.50) !important,
    /* ambient */
    0 14px 36px rgba(0,0,0,.40) !important;
}

/* reuse ::after for an inner corner shadow; make it stronger and slightly larger in the upper-right */
.assist::after{
  content:"" !important;
  position:absolute;
  pointer-events:none;
  border-radius: 18px;
  /* tighter placement, slightly larger footprint to read as a bevel cast onto the white screen */
  inset: 10px 10px auto auto;
  width: 160px; height: 105px;
  /* darker core with smoother falloff to enhance the recessed look */
  background: radial-gradient(135px 88px at 100% 0%,
              rgba(0,0,0,.24) 0%,
              rgba(0,0,0,.14) 46%,
              rgba(0,0,0,.08) 66%,
              transparent 82%);
  /* subtle blur to avoid a hard edge while keeping definition */
  filter: blur(0.6px);
  opacity: .95;
  /* small transform to bias shadow toward the very corner */
  transform: translate(1px, -1px);
}


/* === Assist TV glow + sweep + inner-corner shadow (non-destructive) === */
.assist{
  position: relative;
  overflow: hidden;
  /* Stronger dark-room glow around the whole "screen" */
  box-shadow:
    0 0 0 1px #2f3d49,
    0 0 0 3px #40505f,
    0 0 0 6px rgba(34,46,56,.50),
    -18px 24px 38px rgba(0,0,0,.45),
    /* TV glow */
    0 0 100px rgba(118,255,230,.18),
    0 0 160px rgba(118,255,230,.12);
}

/* Sweep element that glides over the screen surface */
.assist .assist-sweep{
  position:absolute; top:-60%; left:-45%;
  width:110%; height:250%;
  pointer-events:none;
  mix-blend-mode: screen;
  background: radial-gradient(40% 50% at 50% 50%,
              rgba(118,255,230,.35),
              rgba(118,255,230,.18) 40%,
              transparent 72%);
  filter: blur(0.6px);
  animation: assistSweep 6.5s linear infinite;
  z-index: 1;
}
@keyframes assistSweep{
  0%   { transform: translateX(-48%) rotate(12deg); opacity:.60; }
  50%  { transform: translateX(155%) rotate(12deg); opacity:.90; }
  100% { transform: translateX(-48%) rotate(12deg); opacity:.60; }
}

/* Dedicated inner-corner shadow element (top-right inside the border) */
.assist .assist-corner-shadow{
  position:absolute;
  inset: 10px 10px auto auto;
  width: 170px; height: 110px;
  pointer-events:none;
  border-radius: 18px;
  background: radial-gradient(140px 95px at 100% 0%,
              rgba(0,0,0,.22),
              rgba(0,0,0,.14) 55%,
              rgba(0,0,0,.06) 78%,
              transparent 88%);
  filter: blur(0.5px);
  opacity: .95;
  z-index: 2; /* above sweep so the bevel reads correctly */
}

/* Ensure the actual content sits above the effects where needed */
.assist .assist-body, .assist h5 { position: relative; z-index: 3; }


/* === FORCE Assist TV glow, sweep, and corner shadow === */
.assist{
  border-radius: 22px !important;
  position: relative !important;
  overflow: hidden !important;
  /* Keep white screen; assume frame handled elsewhere */
  background-clip: padding-box, border-box !important;
  /* Dark-room glow */
  box-shadow:
    0 0 0 1px #2f3d49,
    0 0 0 3px #40505f,
    0 0 0 6px rgba(34,46,56,.50),
    -18px 24px 38px rgba(0,0,0,.45),
    0 0 110px rgba(118,255,230,.20),
    0 0 160px rgba(118,255,230,.14) !important;
}
.assist .assist-sweep{
  position:absolute; top:-60%; left:-45%;
  width:110%; height:250%;
  pointer-events:none;
  mix-blend-mode: screen;
  background: radial-gradient(40% 50% at 50% 50%,
              rgba(118,255,230,.38),
              rgba(118,255,230,.20) 40%,
              transparent 72%);
  filter: blur(0.6px);
  animation: assistSweep 6.5s linear infinite;
  z-index: 1;
}
@keyframes assistSweep{
  0%   { transform: translateX(-48%) rotate(12deg); opacity:.60; }
  50%  { transform: translateX(155%) rotate(12deg); opacity:.90; }
  100% { transform: translateX(-48%) rotate(12deg); opacity:.60; }
}
.assist .assist-corner-shadow{
  position:absolute;
  inset: 10px 10px auto auto;
  width: 170px; height: 110px;
  pointer-events:none;
  border-radius: 18px;
  background: radial-gradient(140px 95px at 100% 0%,
              rgba(0,0,0,.22),
              rgba(0,0,0,.14) 55%,
              rgba(0,0,0,.06) 78%,
              transparent 88%);
  filter: blur(0.5px);
  opacity: .95;
  z-index: 2;
}
.assist .assist-body, .assist h5 { position: relative; z-index: 3; }


/* === Assist guidance row styles === */
.assist .row-label{ font-weight:600; letter-spacing:.02em; margin-right:6px; }
.assist .good{ color:#00d48b; }
.assist .warn{ color:#ffb020; }
.assist .bad { color:#ff5c9a; }
.assist .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
.assist .mini{ opacity:.9; font-size:.9em; }


/* === KPI Deck distinct styling (only tiles inside .row3grid) === */
.row3grid .viz-tile{
  background: linear-gradient(180deg, rgba(24,46,70,.95) 0%, rgba(12,31,49,.92) 60%, rgba(10,26,41,.92) 100%);
  border: 1px solid rgba(70,120,160,.45);
  box-shadow:
    0 10px 20px rgba(0,0,0,.35),
    inset 1px 1px 0 rgba(255,255,255,.05),
    inset -1px -1px 0 rgba(0,0,0,.25),
    0 0 0 1px rgba(34,211,238,.08);
  backdrop-filter: blur(2px);
}

.row3grid .viz-tile .tile-title{
  letter-spacing:.2px;
  text-shadow: 0 1px 0 rgba(0,0,0,.5);
}

.row3grid{
  position: relative;
  isolation: isolate;
  margin-bottom: 10px;
}
/* a faint divider glow under each KPI row */
.row3grid::after{
  content:"";
  position:absolute;
  left:0; right:0; bottom:-6px; height:6px;
  background: radial-gradient(60% 100% at 50% 0%, rgba(34,211,238,.25) 0%, rgba(34,211,238,0) 70%);
  opacity:.35;
  pointer-events:none;
  filter: blur(3px);
  z-index: -1;
}
/* keep control-model tiles unchanged */
</style>
<style id="cm_conditional_styles">
/* === Conditional Coloring & 80% Target =================================== */
:root{
  --ok: #31d0aa;
  --warn: #f6c945;
  --bad: #ff46c2;
  --tileGlow: 0 0 16px rgba(49,208,170,.35);
  --badGlow: 0 0 16px rgba(255,70,194,.45);
}
.cm-flag { font-size:.75rem; letter-spacing:.3px; padding:.2rem .5rem; border-radius:999px; margin-left:.5rem; opacity:.9 }
.cm-ok { color:var(--ok)}
.cm-warn { color:var(--warn)}
.cm-bad { color:var(--bad)}
.cm-badge { display:inline-flex; align-items:center; gap:.35rem; padding:.25rem .6rem; border-radius:999px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08); margin-left:.5rem }
.cm-pos { color:var(--ok); text-shadow:var(--tileGlow) }
.cm-neg { color:var(--bad); text-shadow:var(--badGlow) }
.cm-target-chip { font-size:.7rem; padding:.2rem .55rem; border-radius:999px; background:linear-gradient(180deg, rgba(49,208,170,.12), rgba(49,208,170,.04)); border:1px solid rgba(49,208,170,.4); color:#bff7ea; margin-left:.5rem }
.cm-bar-warn { background:linear-gradient(90deg, rgba(255,70,194,.35), rgba(246,201,69,.35)); border-radius:8px }
.cm-help { font-size:.75rem; opacity:.8 }
.roi-pos{ color:#00ff9c; text-shadow:0 0 10px rgba(0,255,156,.6);}.roi-neg{ color:#ff33cc; text-shadow:0 0 10px rgba(255,51,204,.5);}</style><style>
/* === Minimal conditional colors (safe) === */
.cm-roi-pos{ color:#34d399 !important; text-shadow:0 0 10px rgba(52,211,153,.35); }
.cm-roi-neg{ color:#ff4dff !important; text-shadow:0 0 10px rgba(255,77,255,.35); }
.cm-crr-ok{ color:#34d399 !important; text-shadow:0 0 10px rgba(52,211,153,.25); }
.cm-crr-bad{ color:#ff4dff !important; text-shadow:0 0 10px rgba(255,77,255,.25); }
.roi-pos{ color:#00ff9c; text-shadow:0 0 10px rgba(0,255,156,.6);}.roi-neg{ color:#ff33cc; text-shadow:0 0 10px rgba(255,51,204,.5);}</style><style>
/* === Control Model Toggle Panel: black background === */
.cm-toggle-panel, .cm-toggle-panel * { 
  /* ensure inner elements inherit dark styling appropriately */
}
.cm-toggle-panel {
  background: #07090B; /* near-black to keep glow edges visible */
  border-radius: 16px;
  box-shadow: 0 6px 24px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.06);
}
.cm-toggle-panel table {
  background: transparent !important;
}
.cm-toggle-panel thead th {
  background: #0E1116 !important;
  color: #CFE7FF !important;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}
.cm-toggle-panel tbody tr {
  background: rgba(255,255,255,0.01) !important;
}
.cm-toggle-panel tbody tr:nth-child(odd) {
  background: rgba(255,255,255,0.03) !important;
}
.cm-toggle-panel .chip, .cm-toggle-panel .badge, .cm-toggle-panel .pill {
  background: rgba(255,255,255,0.06) !important;
  color: #EAF4FF !important;
  border-color: rgba(255,255,255,0.12) !important;
}
.cm-toggle-panel .toggle-switch {
  box-shadow: 0 0 0 2px rgba(0,0,0,0.7);
}
/* keep the "Finalize & Create Action Plan" button floating nicely */
.cm-toggle-panel + .action-footer, .action-footer {
  background: transparent !important;
}
</style>
</head>
<body>
<div class="container">
<div class="kpis" id="kpis">
<div class="kpi"><h5>Total OPEX</h5><div class="value" id="kpi-opex">$0</div></div>
<div class="kpi"><h5>Total CAPEX</h5><div class="value" id="kpi-capex">$0</div></div>
<div class="kpi"><h5>Total Cost</h5><div class="value" id="kpi-total">$0</div></div>
</div>
<div class="finRow">
<div class="fin"><h5>Annual Benefit (modeled)</h5><div class="val" id="fin-avoid">$0</div><small>Σ (Frequency × Consequence × CombinedReduction)</small></div>
<div class="fin"><h5>Annual ROI (benefit vs annualized cost)</h5><div class="val" id="fin-roi">0.0%</div><small>OPEX + CAPEX amortized over 5 years</small></div>
<div class="fin"><h5>Payback (months)</h5><div class="val" id="fin-payback">—</div><small>Upfront (OPEX+CAPEX) / monthly benefit</small></div>
<div class="fin"><h5>NPV (5 yrs @ 7%)</h5><div class="val" id="fin-npv">$0</div><small>Net of CAPEX (t0) &amp; annual OPEX</small></div>
<div class="fin"><h5>Amortized CAPEX (annual)</h5><div class="val" id="fin-amort">$0</div><small>60-month horizon (fixed)</small></div>
</div>
<section class="row3grid">
<div class="viz-tile">
<h5>Cost Split</h5>
<canvas height="138" id="donut" width="320"></canvas>
<div class="viz-sub" id="donutSub"></div>
</div>
<div class="viz-tile">
<h5>ROI Progress <span class="sub-badge" id="roiMaxBadge" style="display:none;"></span></h5>
<canvas height="120" id="roi" width="360"></canvas>
<div class="viz-sub" id="roiSub"></div>
</div>
<div class="viz-tile" style="text-align:center;">
<h5>For every $1 spent, you save</h5>
<canvas height="180" id="perDollarGauge" width="360"></canvas>
<div class="viz-sub" style="margin-top:4px;color:#dbe6f5;"><span id="perDollarSub">$0.00</span> saved per $1</div>
</div>
</section>
<section class="row3grid">
<div class="viz-tile">
<h5>Cumulative Risk Reduction</h5><div class="help-tip" title="CRR = (Σ benefit across covered failures) / (Σ EAL_before across ALL failures). Benefit per failure uses overlap rules: 1 − Π(1 − SEI×IndepFactor). Capped at 100%.">?</div>
<div class="crrRow"><div class="crrBig" id="crrBig">0.0%</div></div>
<canvas height="54" id="crrSpark" width="360"></canvas>
<div class="viz-sub">Session mini-trend (benefit-weighted)</div>
</div>
<div class="viz-tile">
<h5>Average SEI of Selected Controls</h5>
<canvas height="120" id="avgSEI" width="360"></canvas>
<div class="viz-sub" id="avgSEISub">—</div>
</div>
<div class="viz-tile">
<h5>Coverage Progress</h5>
<canvas height="120" id="failCover" width="360"></canvas>
<div class="viz-sub" id="failCoverSub">0 of 0 failures covered</div>
</div>
</section>
<div class="grid">
<div class="table-card" id="tableCard">
<div class="table-head">
<div>Failure</div><div>Control</div><div>Hierarchy</div>
<div>Cost Type</div><div>SEI</div><div>Unit Cost</div><div>Select</div>
</div>
<div class="rows" id="rows"></div>
<div class="actions">
<button class="btn-primary" id="finalize">Finalize &amp; Create Action Plan</button>
</div>
</div>
<div class="right-col">
<div class="lights-card" id="lightsCard">
<div class="lights-title">
<div class="left">
<label for="failureFocus" style="font-size:12px;color:#9fb3c9;letter-spacing:.35px;">Failure focus</label>
<select id="failureFocus" style="background:#0e3050;border:1px solid #174361;color:#dbe6f5;border-radius:8px;padding:6px 8px;font-size:12px;">
<option value="__ALL__">All (overall)</option>
</select>
</div>
<h5>Safety Hierarchy Coverage</h5>
</div>
<div class="lamps" id="lamps"></div>
</div>
<div class="assist" id="assist">
<h5>Analytical Engine Assist</h5>
<div class="pill"><span class="tag tag-rec">RECOMMENDATION</span>
<div id="recText">Selections skew Administrative; consider adding Engineering Control or Substitution for independence.</div>
</div>
<div class="pill"><span class="tag tag-prob">PROBABILITY</span>
<div id="probText">Projected probability to achieve residual risk &lt; 25%: <b>—</b></div>
</div>
<div class="pill"><span class="tag tag-rec">NEXT STEP</span>
<div id="nextStepText">—</div>
</div>

<div class="pill"><span class="tag tag-cost">BUDGET MIX</span>
<div id="budgetText">—</div>
</div>
<div class="pill"><span class="tag tag-cost">COST &amp; ROI</span>
<div id="costText">—</div>
</div>
</div>
</div>
</div>
</div>
<script>
/* seed data (same controls as before) */
const data = [
  { failure:"Manual mixing step", control:"Design out step (contract pre-mix)", hierarchy:"Elimination", sei:0.78, cost:12000, type:"CAPEX", selected:true },
  { failure:"Manual mixing step", control:"Automated sealed mixer (remove manual)", hierarchy:"Elimination", sei:0.82, cost:18000, type:"CAPEX", selected:false },
  { failure:"Manual mixing step", control:"Switch to pre-batched cartridges", hierarchy:"Substitution", sei:0.62, cost:6500, type:"CAPEX", selected:false },
  { failure:"Manual mixing step", control:"Low-VOC/aqueous formulation", hierarchy:"Substitution", sei:0.50, cost:1600, type:"OPEX", selected:false },
  { failure:"Manual mixing step", control:"Interlocked access gate", hierarchy:"Engineering Control", sei:0.48, cost:7000, type:"CAPEX", selected:false },
  { failure:"Manual mixing step", control:"Local Exhaust Ventilation @ mix station", hierarchy:"Engineering Control", sei:0.55, cost:9000, type:"CAPEX", selected:false },
  { failure:"Manual mixing step", control:"Digitized SOP w/ check step", hierarchy:"Administrative", sei:0.34, cost:2500, type:"OPEX", selected:true },
  { failure:"Manual mixing step", control:"Andon escalation for deviations", hierarchy:"Administrative", sei:0.30, cost:1200, type:"OPEX", selected:false },
  { failure:"Manual mixing step", control:"Face shield + splash goggles", hierarchy:"PPE", sei:0.30, cost:900, type:"OPEX", selected:true },
  { failure:"Manual mixing step", control:"Chemical apron & sleeves", hierarchy:"PPE", sei:0.26, cost:700, type:"OPEX", selected:false },

  { failure:"Solvent exposure", control:"Enclosed dispense cabinet (remove open handling)", hierarchy:"Elimination", sei:0.72, cost:12000, type:"CAPEX", selected:false },
  { failure:"Solvent exposure", control:"Off-site blending / bulk pre-mix", hierarchy:"Elimination", sei:0.76, cost:15000, type:"CAPEX", selected:false },
  { failure:"Solvent exposure", control:"Non-hazardous solvent alternative", hierarchy:"Substitution", sei:0.60, cost:6000, type:"CAPEX", selected:false },
  { failure:"Solvent exposure", control:"Reduced-strength solvent (tiered)", hierarchy:"Substitution", sei:0.44, cost:1500, type:"OPEX", selected:false },
  { failure:"Solvent exposure", control:"LEV at pour/fill points", hierarchy:"Engineering Control", sei:0.52, cost:8000, type:"CAPEX", selected:false },
  { failure:"Solvent exposure", control:"Light curtain interlock", hierarchy:"Engineering Control", sei:0.58, cost:11000, type:"CAPEX", selected:false },
  { failure:"Solvent exposure", control:"Digital work prompts + timer", hierarchy:"Administrative", sei:0.31, cost:1200, type:"OPEX", selected:false },
  { failure:"Solvent exposure", control:"Peer verification (2-out-of-3)", hierarchy:"Administrative", sei:0.38, cost:2500, type:"OPEX", selected:false },
  { failure:"Solvent exposure", control:"Respirator with OV cartridges", hierarchy:"PPE", sei:0.36, cost:1300, type:"OPEX", selected:false },
  { failure:"Solvent exposure", control:"Splash shield visor", hierarchy:"PPE", sei:0.25, cost:700, type:"OPEX", selected:false },

  { failure:"Machine startle events", control:"Robotic transfer (remove human in hazard zone)", hierarchy:"Elimination", sei:0.85, cost:22000, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Auto part ejection chute", hierarchy:"Elimination", sei:0.70, cost:14000, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Soft-jaw tooling", hierarchy:"Substitution", sei:0.55, cost:4500, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Low-force gripper swap", hierarchy:"Substitution", sei:0.50, cost:3500, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Dual channel E-Stop", hierarchy:"Engineering Control", sei:0.55, cost:8000, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Guarding redesign", hierarchy:"Engineering Control", sei:0.52, cost:6000, type:"CAPEX", selected:false },
  { failure:"Machine startle events", control:"Pre-energization test step", hierarchy:"Administrative", sei:0.35, cost:1800, type:"OPEX", selected:false },
  { failure:"Machine startle events", control:"Kitting checklist (visuals)", hierarchy:"Administrative", sei:0.28, cost:1200, type:"OPEX", selected:false },
  { failure:"Machine startle events", control:"Cut-resistant gloves", hierarchy:"PPE", sei:0.20, cost:500, type:"OPEX", selected:false },
  { failure:"Machine startle events", control:"Face shield", hierarchy:"PPE", sei:0.22, cost:700, type:"OPEX", selected:false }
];

/* failure meta: frequencies and consequences (example defaults; replace with CRR values when available) */
const failureMeta = {
  "Manual mixing step":    { frequency: 0.30, consequence: 20000, labelLik: "Possible", labelSev: "Moderate" },
  "Solvent exposure":      { frequency: 0.30, consequence: 15000, labelLik: "Possible", labelSev: "Moderate" },
  "Machine startle events":{ frequency: 0.10, consequence: 75000, labelLik: "Unlikely", labelSev: "Major" }
};

/* independence factors by hierarchy */
const indep = {
  "Elimination": 1.00,
  "Substitution": 0.95,
  "Engineering Control": 0.90,
  "Administrative": 0.70,
  "PPE": 0.60
};
</script>
<script>
const rowsEl=document.getElementById('rows');
function rowHTML(r,i){return `<div class="row" data-idx="${i}">
  <div>${r.failure}</div><div>${r.control}</div>
  <div><span class="chip">${r.hierarchy}</span></div>
  <div><span class="chip">${r.type}</span></div>
  <div>${Math.round(r.sei*100)}%</div>
  <div>$${r.cost.toLocaleString()}</div>
  <div><div class="toggle ${r.selected?'on':''}" role="switch" aria-checked="${r.selected}" tabindex="0"><i></i></div></div>
</div>`}
function renderRows(){
  rowsEl.innerHTML=data.map(rowHTML).join('');
  [...rowsEl.querySelectorAll('.toggle')].forEach((tg,i)=>{
    tg.addEventListener('click',()=>{data[i].selected=!data[i].selected;tg.classList.toggle('on');recompute();});
    tg.addEventListener('keydown',(e)=>{if(e.key==='Enter'||e.key===' '){e.preventDefault();tg.click();}});
  });
}
renderRows();
</script>
<script>
// === RISE CM1 v3u — risk math utilities (always included) ====================


// === Knob access helper ===
function KNOBS(){
  if (window && window.tuningKnobs) return window.tuningKnobs;
  try{
    return (typeof KNOB_DEFAULTS!=='undefined' ? KNOB_DEFAULTS : {});
  }catch(e){ return {}; }
}
// Map hierarchy label -> weight key
function weightForHierarchy(h){
  const k = (h||'').toLowerCase();
  if(k.startsWith('elim')) return 'ELIM';
  if(k.startsWith('subst')) return 'SUB';
  if(k.startsWith('engine')) return 'ENG';
  if(k.startsWith('admin')) return 'ADMIN';
  if(k.startsWith('ppe')) return 'PPE';
  return 'ADMIN';
}
// Combine a list of effectiveness values as independent layers: 1 - Π(1 - e)
function combineIndependent(effs){
  let prod = 1.0;
  for(const e of effs){
    const clamped = Math.max(0, Math.min(0.999, e||0));
    prod *= (1 - clamped);
  }
  return 1 - prod;
}

// Apply diminishing returns within a group using overlap coefficient `k` (0..1).
// Sort by SEI desc; marginal multiplier for nth control is (1-k)^(n-1).
function combineGroupWithDiminishing(seiList, k){
  const sorted = [...seiList].sort((a,b)=>b-a).map(x=>Math.max(0,Math.min(0.999,x)));
  const adj = [];
  const damp = (1 - Math.max(0,Math.min(1,k||0)));
  for(let i=0;i<sorted.length;i++){
    const marginal = Math.pow(damp, i); // smaller each additional control
    adj.push(sorted[i] * marginal);
  }
  return combineIndependent(adj);
}

// Independence factor by hierarchy (calibration knobs)
const HIER_INDEP = {
  "Elimination": 1.00,
  "Substitution": 0.95,
  "Engineering Control": 0.90,
  "Administrative": 0.70,
  "PPE": 0.60
};

// Default overlap coefficients if not explicitly on the row
function defaultOverlapCoeff(group){
  const map = {
    "ENG_GUARDS": 0.65,
    "ADMIN_CONTROLS": 0.45,
    "PPE": 0.35,
    "SUBSTITUTION": 0.20,
    "ELIMINATION": 0.00,
    "PROCESS_ALARMS": 0.60,
    "INSPECTIONS": 0.55,
    "HUMAN_MONITORING": 0.60,
    "GEN": 0.40
  };
  return map[group] ?? 0.40;
}

// Compute blended effectiveness for a single failure with selected controls.
function computeFailureBlend(items){
  if(!items || !items.length) return 0;
  // Normalize SEI to 0..1
  const norm = items.map(x => ({
    eff: (x.SEI>1? x.SEI/100 : (x.SEI||0)),
    h: x.Hierarchy || x.HIERARCHY || "",
    g: x.OverlapGroup || x.OVERLAP_GROUP || "",
    k: (typeof x.OverlapCoeff==="number"? x.OverlapCoeff : defaultOverlapCoeff(x.OverlapGroup||x.OVERLAP_GROUP||"GEN")),
    beta: (typeof x.Common_Cause_Beta==="number"? x.Common_Cause_Beta : 1.0)
  }));
  // Group by overlap domain
  const byGroup = {};
  for(const r of norm){
    const key = r.g || r.h || "GEN";
    if(!byGroup[key]) byGroup[key] = [];
    // Apply independence beta directly to effective SEI
    const indepScale = Math.max(0, Math.min(1, r.beta));
    byGroup[key].push(r.eff * indepScale);
  }
  // Combine inside each group with diminishing returns
  const groupEffs = [];
  Object.keys(byGroup).forEach(key=>{
    const baseK = (norm.find(x => (x.g||x.h||"GEN")===key)?.k) ?? defaultOverlapCoeff(key);
const kAdj = Math.max(0, Math.min(1, (baseK * (KNOBS().OVERLAP_RULE_STRENGTH ?? 1))));
const kUsed = ( (kAdj + (KNOBS().DIMINISHING_RETURNS_K ?? kAdj)) / 2 );
const eff = combineGroupWithDiminishing(byGroup[key], kUsed);
    groupEffs.push(eff);
  });
  // Combine groups independently and apply hierarchy independence weights multiplicatively
  let combined = combineIndependent(groupEffs);
  const layers = norm.map(x => (KNOBS().BENEFIT_WEIGHTS ? KNOBS().BENEFIT_WEIGHTS[weightForHierarchy(x.h)] : (HIER_INDEP[x.h] ?? 0.6)) || 0.6 );
  const avgIndep = layers.length? layers.reduce((a,b)=>a+b,0)/layers.length : 1.0;
  combined = combined * avgIndep;
// Mix bonus for variety across hierarchy types
const uniqTypes = new Set(norm.map(x=>weightForHierarchy(x.h))).size;
const minTypes = KNOBS().MIX_MIN_UNIQUE_TYPES ?? 3;
const mixW = KNOBS().MIX_BONUS_WEIGHT ?? 0;
if(uniqTypes >= minTypes){ combined = Math.min(0.999, combined * (1 + mixW)); }
// Cap
  const hasElim = norm.some(x => (x.h||"").toLowerCase().startsWith("elimination"));
  const cap = hasElim? 1.0 : 0.999;
  return Math.max(0, Math.min(cap, combined));
}

// Compute CRR vs ALL failures (benefit-weighted):
// CRR = Σ (EAL_before(f) * reduction(f)) / Σ EAL_before(f)
function computeCRR(failures){
  let num = 0, den = 0;
  for(const f of failures){
    const ealBefore = Math.max(0, (f.Frequency || f.freq || 0) * (f.Consequence || f.cons || 0));
    den += ealBefore;
    const red = computeFailureBlend(f.controls || []);
    num += ealBefore * red;
  }
  if(den<=0) return 0;
  return Math.max(0, Math.min(1, num/den));
}
</script>
<script>
const money = v => "$"+v.toLocaleString();
const donut = document.getElementById('donut').getContext('2d');
const roi = document.getElementById('roi').getContext('2d');
const failCover = document.getElementById('failCover').getContext('2d');
const crrSpark = document.getElementById('crrSpark').getContext('2d');
const avgSEI = document.getElementById('avgSEI').getContext('2d');
const perGauge = document.getElementById('perDollarGauge').getContext('2d');
const roiBadge = document.getElementById('roiMaxBadge');
let sparkSeries=[0.4,0.5,0.58];

function drawRingSlice(ctx,cx,cy,start,end,R,r,color){
  ctx.beginPath();ctx.arc(cx,cy,R,start,end);ctx.arc(cx,cy,r,end,start,true);ctx.closePath();
  ctx.fillStyle=color;ctx.shadowColor=color;ctx.shadowBlur=12;ctx.fill();ctx.shadowBlur=0;
}
function drawDonut(opex,capex){
  const w=320,h=138;donut.clearRect(0,0,w,h);const cx=w/2,cy=h/2-6,outer=52,inner=28;
  const total=Math.max(1,opex+capex),a1=(capex/total)*Math.PI*2;
  drawRingSlice(donut,cx,cy,0,a1,outer,inner,"#2bd1f9");
  drawRingSlice(donut,cx,cy,a1,Math.PI*2,outer,inner,"#6a74ff");
  document.getElementById('donutSub').textContent=`OPEX ${Math.round(opex/total*100)}% • CAPEX ${Math.round(capex/total*100)}%`;
}
function chooseRoiMax(pct){
  const stops=[50,100,150,300,600,1000,3000,6000,10000];
  for(const s of stops){ if(pct<=s) return s; }
  return 20000;
}

function drawROIbar(roiPct){
  // roiPct can be negative. We render a bar with 0 at the left edge; negatives draw in magenta to 0% marker,
  // positives draw cyan->green. Positive auto-scale chooses max; negative is clamped to -100%.
  if(!Number.isFinite(roiPct)) roiPct = 0;
  const posMax = chooseRoiMax(Math.max(0,roiPct));
  const negMin = -100; // clamp lower to -100%
  const range = posMax - negMin; // total span shown
  const w=roi.canvas.width,h=roi.canvas.height,pad=14,y=h/2;
  roi.clearRect(0,0,w,h);
  // Track
  roi.fillStyle="#10324f";roi.fillRect(pad,y-10,w-2*pad,20);
  // Zero position
  const zeroX = pad + (0 - negMin) / range * (w-2*pad);
  // Fill negative
  if(roiPct<0){
    const frac = Math.min(1, Math.abs(roiPct/negMin));
    const negW = (w-2*pad) * frac * ((0 - negMin) / range);
    roi.fillStyle="#a400c2"; roi.shadowColor="#ff4dff"; roi.shadowBlur=10;
    roi.fillRect(zeroX - negW, y-10, negW, 20);
    roi.shadowBlur=0;
  }
  // Fill positive
  if(roiPct>0){
    const frac = Math.min(1, roiPct/posMax);
    const grad=roi.createLinearGradient(zeroX,0, zeroX + (w-2*pad)*frac*((posMax)/(range)),0);
    grad.addColorStop(0,"#22d3ee"); grad.addColorStop(1,"#34d399");
    roi.fillStyle=grad; roi.shadowColor="#22d3ee"; roi.shadowBlur=10;
    roi.fillRect(zeroX, y-10, (w-2*pad)*(roiPct/posMax)*(posMax/(range)), 20);
    roi.shadowBlur=0;
  }
  // Axis labels
  roi.fillStyle="#bcd0e4"; roi.font="12px ui-sans-serif"; roi.textAlign="left"; roi.fillText(negMin+"%", pad, y+28);
  roi.textAlign="center"; roi.fillText("0%", zeroX, y+28);
  roi.textAlign="right"; roi.fillText(posMax+"%", w-pad, y+28);
  // Subtitle + badge
  const sub = document.getElementById('roiSub'); sub.textContent=`Annual ROI ≈ ${roiPct.toFixed(1)}%`;
  const badge = document.getElementById('roiMaxBadge');
  badge.style.display = (roiPct>posMax*0.95 ? 'inline-block' : 'inline-block'); // always show target scale
  badge.textContent = `scale: ${negMin}% to ${posMax}%`;
}
function drawFailCoverBar(covered,total){
  const w=failCover.canvas.width,h=failCover.canvas.height,pad=12;failCover.clearRect(0,0,w,h);
  const pct=total>0?covered/total:0;failCover.fillStyle="#10324f";failCover.fillRect(pad,h/2-10,w-2*pad,20);
  const grad=failCover.createLinearGradient(pad,0,pad+(w-2*pad)*pct*(w-2*pad),0);grad.addColorStop(0,"#a78bfa");grad.addColorStop(1,"#22d3ee");
  failCover.fillStyle=grad;failCover.shadowColor="#a78bfa";failCover.shadowBlur=10;failCover.fillRect(pad,h/2-10,(w-2*pad)*pct,20);failCover.shadowBlur=0;
  document.getElementById('failCoverSub').textContent=`${covered} of ${total} failures covered`;
}
function drawSpark(series){
  const w=crrSpark.canvas.width,h=crrSpark.canvas.height,pad=8;crrSpark.clearRect(0,0,w,h);
  crrSpark.strokeStyle="rgba(255,255,255,.12)";crrSpark.setLineDash([3,4]);crrSpark.beginPath();
  const y50=h-pad-(h-2*pad)*0.5;crrSpark.moveTo(pad,y50);crrSpark.lineTo(w-pad,y50);crrSpark.stroke();crrSpark.setLineDash([]);
  crrSpark.strokeStyle="#22d3ee";crrSpark.lineWidth=2;crrSpark.beginPath();
  series.forEach((v,i)=>{const x=pad+(w-2*pad)*(i/(series.length-1)),y=h-pad-(h-2*pad)*v;i?crrSpark.lineTo(x,y):crrSpark.moveTo(x,y);});crrSpark.stroke();
}
function drawAvgSEI(sei){
  const w=avgSEI.canvas.width,h=avgSEI.canvas.height,cx=w/2,cy=h/2+24,R=56;avgSEI.clearRect(0,0,w,h);
  avgSEI.lineWidth=14;avgSEI.strokeStyle="#10324f";avgSEI.beginPath();avgSEI.arc(cx,cy,R,Math.PI,0);avgSEI.stroke();
  const end=Math.PI+(Math.PI*Math.max(0,Math.min(1,sei)));const grad=avgSEI.createLinearGradient(cx-R,0,cx+R,0);grad.addColorStop(0,"#6a74ff");grad.addColorStop(1,"#22d3ee");
  avgSEI.strokeStyle=grad;avgSEI.shadowColor="#22d3ee";avgSEI.shadowBlur=10;avgSEI.beginPath();avgSEI.arc(cx,cy,R,Math.PI,end);avgSEI.stroke();avgSEI.shadowBlur=0;
  avgSEI.fillStyle="#dbe6f5";avgSEI.font="bold 22px ui-sans-serif";avgSEI.textAlign="center";avgSEI.fillText(`${Math.round(sei*100)}%`,cx,cy-6);
}
function drawSpeedometer(perDollar){
  const ctx=perGauge,w=ctx.canvas.width,h=ctx.canvas.height;ctx.clearRect(0,0,w,h);
  const cx=w/2, cy= Math.floor(h*0.62), R=62;
  ctx.lineWidth=18;ctx.strokeStyle="#0f2a43";ctx.beginPath();ctx.arc(cx,cy,R,Math.PI,0);ctx.stroke();
  const seg=(s,e,c)=>{const a1=Math.PI+Math.PI*s/5, a2=Math.PI+Math.PI*e/5;ctx.strokeStyle=c;ctx.shadowColor=c;ctx.shadowBlur=12;ctx.beginPath();ctx.arc(cx,cy,R,a1,a2);ctx.stroke();ctx.shadowBlur=0;};
  seg(0,1,"#ff4dff"); seg(1,1.25,"#ffb84d"); seg(1.25,5,"#34d399");
  const maxX=5, clamped=Math.max(0,Math.min(maxX,perDollar)), pct=clamped/maxX;
  const grad=ctx.createLinearGradient(cx-R,0,cx+R,0);grad.addColorStop(0,"#ff4dff"); grad.addColorStop(0.25,"#ffb84d"); grad.addColorStop(1,"#34d399");
  ctx.strokeStyle=grad;ctx.lineWidth=20;ctx.globalAlpha=.25;ctx.beginPath();ctx.arc(cx,cy,R,Math.PI,Math.PI+Math.PI*pct);ctx.stroke();ctx.globalAlpha=1;
  ctx.strokeStyle="rgba(255,255,255,.18)";ctx.lineWidth=2;
  for(let i=0;i<=5;i++){const a=Math.PI+Math.PI*(i/5),x1=cx+(R+4)*Math.cos(a),y1=cy+(R+4)*Math.sin(a),x2=cx+(R-12)*Math.cos(a),y2=cy+(R-12)*Math.sin(a);ctx.beginPath();ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();}
  const nAng=Math.PI+Math.PI*pct, nx=cx+(R-22)*Math.cos(nAng), ny=cy+(R-22)*Math.sin(nAng);
  ctx.strokeStyle="#e2e8f0";ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(nx,ny);ctx.stroke();ctx.fillStyle="#e2e8f0";ctx.beginPath();ctx.arc(cx,cy,4.2,0,Math.PI*2);ctx.fill();
  ctx.fillStyle = (perDollar >= 1 ? "#34d399" : "#f472b6");ctx.font="900 30px ui-sans-serif,system-ui";ctx.textAlign="center";
  ctx.fillText(`$${perDollar.toFixed(2)}`, cx, Math.min(h-10, cy + R + 28));
}
</script>
<script>
const lampsEl=document.getElementById('lamps');
function renderLamps(status,tips){
  lampsEl.innerHTML=["Elimination","Substitution","Engineering Control","Administrative","PPE"].map(h=>{
    const on=status[h]?'on':'';const tip=(tips[h]||[]).join(", ")||"No selections for this level";
    return `<div class="lamp" title="${tip}"><div class="dot ${on}"></div><div class="lamp-label">${h}</div><div class="lamp-tip">${status[h]?'ON':'OFF'}</div></div>`;
  }).join('');
}
</script>
<script>

function recompute(){
  try{ const thr=(KNOBS().ROI_NEG_THRESHOLD ?? (typeof KNOB_DEFAULTS!=='undefined' ? KNOB_DEFAULTS.ROI_NEG_THRESHOLD : 0)); const chip=document.getElementById("roiThreshChip"); if(chip){ chip.textContent=`Thresh: ${(thr*100).toFixed(0)}%`; } }catch(e){}

  try{ const cap=(KNOBS().PAYBACK_CAP_MONTHS ?? (typeof KNOB_DEFAULTS!=='undefined' ? KNOB_DEFAULTS.PAYBACK_CAP_MONTHS : 60));
       const pc=document.getElementById("payCapChip"); if(pc){ pc.textContent=`Cap: ${cap} mo`; } }catch(e){}

  const sel=data.filter(d=>d.selected);
  const opex=sel.filter(d=>d.type==="OPEX").reduce((a,b)=>a+b.cost,0);
  const capex=sel.filter(d=>d.type==="CAPEX").reduce((a,b)=>a+b.cost,0);
  const total=opex+capex;

  document.getElementById('kpi-opex').textContent=money(opex);
  document.getElementById('kpi-capex').textContent=money(capex);
  document.getElementById('kpi-total').textContent=money(total);

  // Build per-failure objects with overlap groups
  const failureNames=[...new Set(data.map(d=>d.failure))];
  const failureObjs=[];
  let benefitTotal=0, ealBeforeTotal=0, covered=0;

  for(const f of failureNames){
    const meta=failureMeta[f];
    if(!meta) continue;
    const ealBefore = Math.max(0, meta.frequency * meta.consequence);
    ealBeforeTotal += ealBefore;

    // map to overlap groups (simple defaults)
    const mapGroup = (h)=>{
      if(h==="Engineering Control") return "ENG_GUARDS";
      if(h==="Administrative") return "ADMIN_CONTROLS";
      if(h==="PPE") return "PPE";
      if(h==="Substitution") return "SUBSTITUTION";
      if(h==="Elimination") return "ELIMINATION";
      return "GEN";
    };

    const items = sel.filter(r=>r.failure===f).map(r=>({
      SEI: r.sei, Hierarchy: r.hierarchy, OverlapGroup: mapGroup(r.hierarchy)
    }));

    // compute reduction via utilities
    const reduction = computeFailureBlend(items);
    if(items.length>0 && reduction>0){ covered += 1; }

    const benefit = ealBefore * reduction;
    benefitTotal += benefit;

    failureObjs.push({ name:f, Frequency: meta.frequency, Consequence: meta.consequence, controls: items });
  }

  // Apply benefit scaler from knobs
  benefitTotal = benefitTotal * (KNOBS().BENEFIT_SCALER_BASE ?? 1.0);

  // Costs & finance
  const amortAnnual=capex/5;
  const annualCost=opex+amortAnnual;
  // If there is no annual cost, treat ROI baseline as 0% instead of -100%
  const perDollar = annualCost>0 ? (benefitTotal/annualCost) : 0;
  const roiPct = annualCost>0 ? ((perDollar - 1) * 100) : 0;

  document.getElementById('fin-avoid').textContent=money(Math.round(benefitTotal));
  document.getElementById('fin-roi').textContent=(isFinite(roiPct)?roiPct:0).toFixed(1)+"%";
  try{
    const thr=(KNOBS().ROI_NEG_THRESHOLD ?? (typeof KNOB_DEFAULTS!=='undefined' ? KNOB_DEFAULTS.ROI_NEG_THRESHOLD : 0));
    const el=document.getElementById('fin-roi');
    const roiVal=parseFloat(String(el.textContent).replace(/[^0-9.+-]/g,''));
    el.classList.remove('roi-pos','roi-neg');
    if(!Number.isNaN(roiVal)){
      if((roiVal/100)>=thr){ el.classList.add('roi-pos'); } else { el.classList.add('roi-neg'); }
    }
  }catch(e){}

  const monthlyBenefit = benefitTotal/12;
  const paybackMonths = monthlyBenefit>0 ? Math.ceil((opex+capex)/monthlyBenefit) : null;
  const __cap = (KNOBS().PAYBACK_CAP_MONTHS ?? (typeof KNOB_DEFAULTS!=='undefined' ? KNOB_DEFAULTS.PAYBACK_CAP_MONTHS : 60));
document.getElementById('fin-payback').textContent = (paybackMonths ? Math.min(paybackMonths, __cap) : "—");
  const discount=(KNOBS().NPV_DISCOUNT_RATE ?? 0.07),years=5;let pv=0;for(let t=1;t<=years;t++){pv+=(benefitTotal-opex)/Math.pow(1+discount,t)} const npv=pv-capex;
  const npvEl=document.getElementById('fin-npv'); npvEl.textContent=money(Math.round(npv)); npvEl.classList.remove('npv-pos','npv-neg','npv-neutral'); npvEl.classList.add(npv>0?'npv-pos':(npv<0?'npv-neg':'npv-neutral'));

  // Color thresholds
  const crrEl = document.getElementById('crrBig');
  if(crrEl){
    const tgt = KNOBS().CRR_TARGET ?? 0.80;
    const crrVal = parseFloat(crrEl.textContent) || 0;
    if(crrVal >= (tgt*100)) { crrEl.style.color = '#70f7c1'; }
    else { crrEl.style.color = '#ff4dd2'; }
  }
  const roiEl = document.getElementById('fin-roi');
  if(roiEl){
    const thr = (KNOBS().ROI_NEG_THRESHOLD ?? 0) * 100;
    const roiVal = parseFloat(roiEl.textContent) || 0;
    roiEl.style.color = (roiVal >= thr ? '#70f7c1' : '#ff4dd2');
  }
  // Update NPV label to reflect discount rate
  // removed invalid :contains selector that broke rendering

  document.getElementById('fin-amort').textContent=money(Math.round(amortAnnual));

  // Visuals
  drawDonut(opex,capex);
  drawROIbar(isFinite(roiPct)?roiPct:0);
  drawSpeedometer(perDollar);
  document.getElementById('perDollarSub').textContent=`$${perDollar.toFixed(2)}`;

  drawFailCoverBar(covered, failureNames.length);

  // CRR via computeCRR across ALL failures
  const crr = computeCRR(failureObjs);
  document.getElementById('crrBig').textContent=(crr*100).toFixed(1)+"%";
  sparkSeries.push(crr);if(sparkSeries.length>40)sparkSeries.shift();
  drawSpark(sparkSeries);

  const avg=sel.length?sel.reduce((a,b)=>a+b.sei,0)/sel.length:0;
  drawAvgSEI(avg);

  // lights
  const dd=document.getElementById('failureFocus');
  if(dd && dd.options.length===1){failureNames.forEach(f=>{const o=document.createElement('option');o.value=f;o.textContent=f;dd.appendChild(o)});dd.addEventListener('change',recompute)}
  const focus=dd?dd.value:"__ALL__";
  const subset=(focus==="__ALL__")?sel:sel.filter(x=>x.failure===focus);
  const has={"Elimination":false,"Substitution":false,"Engineering Control":false,"Administrative":false,"PPE":false};
  const tips={"Elimination":[],"Substitution":[],"Engineering Control":[],"Administrative":[],"PPE":[]};
  subset.forEach(x=>{has[x.hierarchy]=true;tips[x.hierarchy].push(x.control)});
  renderLamps(has,tips);
  
  // ==== Analytical Assist (dynamic guidance) ====
  (function(){
    const sel = data.filter(d=>d.selected);
    const totalSel = sel.length;
    const counts = {Elimination:0, Substitution:0, 'Engineering Control':0, Administrative:0, PPE:0};
    const spend = {OPEX:0, CAPEX:0};
    sel.forEach(x=>{ counts[x.hierarchy]=(counts[x.hierarchy]||0)+1; spend[x.type]+=x.cost; });

    const uniqTypes = Object.keys(counts).filter(k=>counts[k]>0).length;
    const totalCost = spend.OPEX + spend.CAPEX;
    const opexShare = totalCost>0 ? spend.OPEX/totalCost : 0;
    const capexShare = totalCost>0 ? spend.CAPEX/totalCost : 0;

    // Tiles / metrics already on page
    const readNum = (id) => parseFloat((document.getElementById(id)?.textContent||'0').replace(/[^0-9.\-]/g,''))||0;
    const crrPct = readNum('crrBig');             // %
    const roiPct = readNum('fin-roi');            // %
    const npvVal = readNum('fin-npv');            // $
    const perDollar = parseFloat((document.getElementById('perDollarSub')?.textContent||'0').replace(/[^0-9.\-]/g,''))||0;

    // Coverage (X of Y)
    let covered = 0, total = 0;
    const covMeta = document.querySelector('[data-tile=\"coverage\"] .meta, .coverage-tile .meta');
    if (covMeta){
      const m = covMeta.textContent.match(/(\d+)\s*of\s*(\d+)/i);
      if (m){ covered = +m[1]; total = +m[2]; }
    }

    // Overlap detection: duplicate hierarchy within same failure
    const byFail = {};
    sel.forEach(s=>{ (byFail[s.failure]||(byFail[s.failure]=[])).push(s); });
    let dupCount = 0;
    Object.values(byFail).forEach(list=>{
      const seen = new Set();
      list.forEach(x=>{
        const k = x.hierarchy;
        if (seen.has(k)) dupCount++;
        else seen.add(k);
      });
    });

    // Sensitivity knobs (fallbacks if not defined)
    const TK = (window.tuningKnobs||{});
    const targetCRR = (TK.crrTarget ?? 0.80) * 100;
    const minMix    = TK.mixMinTypes ?? TK.mixMinUniqueTypes ?? 3; // threshold for "balanced mix"
    const roiThresh = (TK.roiPositive ?? 0.00) * 100;

    // ---- Probability heuristic (more responsive) ----
    // Components:
    //  - Coverage (40% weight): strong penalty if uncovered failures remain.
    //  - CRR (30%): proximity to target.
    //  - Overlap/Mix (15%): reward diverse layers, penalize duplicates.
    //  - Economics (15%): ROI sign and NPV sign.
    const wCov=0.40, wCrr=0.30, wMix=0.15, wEcon=0.15;

    const covScore = (total>0) ? (covered/total) : (totalSel>0?0.5:0); // 0..1
    const crrScore = (crrPct>0) ? Math.min(crrPct/targetCRR, 1) : 0;
    const mixScore = Math.max(0, Math.min(1, (uniqTypes/minMix))) * (dupCount? 0.75:1); // duplicates reduce
    let econScore = 0.5;
    if (roiPct >= roiThresh && npvVal >= 0) econScore = 1.0;
    else if (roiPct >= 0 && npvVal >= 0)  econScore = 0.8;
    else if (roiPct < 0 && npvVal < 0)    econScore = 0.2;
    else                                  econScore = 0.5;

    let prob = (wCov*covScore + wCrr*crrScore + wMix*mixScore + wEcon*econScore);
    prob = Math.max(0.05, Math.min(0.98, prob));
    const probPct = Math.round(prob*100);

    // ---- Recommendations (more sensitive) ----
    const recs = [];
    if (total>0 && covered < total) recs.push(`Cover gaps: ${covered} of ${total} failures covered—add at least one control to each.`);
    if (crrPct < targetCRR)         recs.push(`CRR ${crrPct.toFixed(1)}% < target ${targetCRR.toFixed(0)}% — add an Engineering/Elimination control on the riskiest uncovered failure.`);
    if (dupCount>0)                 recs.push(`Overlap risk detected (duplicate types on same failure) — swap one for a different hierarchy to unlock more reduction.`);
    if (uniqTypes < minMix)         recs.push(`Mix is light (only ${uniqTypes} type${uniqTypes==1?'':'s'}) — add another hierarchy (e.g., Substitution or Engineering) for a mix bonus.`);
    if (roiPct < roiThresh || npvVal < 0) recs.push(`Economics weak (ROI ${roiPct.toFixed(1)}%, NPV ${npvVal<0?'neg':'pos'}) — trade out high-cost low-SEI picks for better SEI per $.`);
    if (recs.length===0)            recs.push(`Portfolio is well balanced — lock improvements and assign actions.`);

    // ---- Next Step prioritization ----
    let next = recs[0];
    // If coverage is incomplete, force this as top action
    if (total>0 && covered<total) next = 'Add one control to each uncovered failure first, then diversify types.';
    // If economics negative, focus on quick wins
    else if (roiPct < 0 || npvVal < 0) next = 'Flip economics: replace 1–2 costly low-SEI controls with higher SEI/$ (Substitution/Admin quick wins).';
    // Else if CRR still below target
    else if (crrPct < targetCRR) next = 'Push CRR to target with one Engineering control on top risk; avoid stacking duplicates on same failure.';

    // ---- Compose lines for the Assist panel ----
    const body = document.getElementById('assistBody');
    if (body){
      body.innerHTML = [
  `<div class="line"><strong>NEXT:</strong> ${next}</div>`,
  `<div class="line"><strong>PROB:</strong> ${probPct}%</div>`,
  recs.slice(0,3).map(t=>`<div class="line">• ${t}</div>`).join('')
].join('');
    }
  })();


}
function init(){
  try{ recompute(); }catch(e){ console.error('recompute error on init', e); }
  setInterval(recompute,1200);
  window.addEventListener('tuning:updated', ()=>{ try{ recompute(); }catch(e){} });
  document.getElementById('finalize').addEventListener('click',()=>alert('Action Plan draft created — attaches to Action Tracker in RISE.'));
}
if(document.readyState==='complete')init();else window.addEventListener('DOMContentLoaded',init);
</script>
<script id="cm_colorize_v1">
(function(){
  function parsePct(text){
    var m = (text||'').match(/-?\d+(?:\.\d+)?/);
    return m ? parseFloat(m[0]) : null;
  }
  function colorize(){
    var roiEl = document.getElementById('fin-roi');
    if(roiEl){
      var v = parsePct(roiEl.textContent);
      roiEl.classList.remove('cm-roi-pos','cm-roi-neg');
      if(v !== null){
        roiEl.classList.add(v >= 0 ? 'cm-roi-pos' : 'cm-roi-neg');
      }
    }
    var crrEl = document.getElementById('crrBig');
    if(crrEl){
      var c = parsePct(crrEl.textContent);
      // Read live CRR target from tuning knobs if available (0-1), else fall back to defaults (0.80).
      var target = (window.tuningKnobs && typeof window.tuningKnobs.CRR_TARGET === 'number')
                    ? window.tuningKnobs.CRR_TARGET
                    : (typeof KNOB_DEFAULTS !== 'undefined' && KNOB_DEFAULTS.CRR_TARGET ? KNOB_DEFAULTS.CRR_TARGET : 0.80);
      // If displayed c is in % (0-100), convert to fraction for comparison
      var cFrac = (c !== null && c > 1) ? (c/100) : c;
      crrEl.classList.remove('cm-crr-green','cm-crr-red');
      if(cFrac !== null){
        crrEl.classList.add(cFrac >= target ? 'cm-crr-green' : 'cm-crr-red');
      }
    }
}
}
    var crrEl = document.getElementById('crrBig');
    if(crrEl){
      var c = parsePct(crrEl.textContent);
      crrEl.classList.remove('cm-crr-ok','cm-crr-bad');
      if(c !== null){
        crrEl.classList.add(c >= 80 ? 'cm-crr-ok' : 'cm-crr-bad');
      }
    }
  }
  document.addEventListener('DOMContentLoaded', function(){
    colorize();
    setInterval(colorize, 800);
  });
})();
</script>
<style>
/* ==== RISE: Admin Tabs & Tuning Knobs (improved) ==== */
.rise-admin-header{
  position: fixed; top: 8px; right: 12px; z-index: 9999;
  display:flex; gap:.5rem; background: rgba(10,20,28,.5);
  backdrop-filter: blur(6px); padding:6px; border-radius:12px; border:1px solid rgba(255,255,255,.08);
  box-shadow: 0 8px 30px rgba(0,0,0,.4);
}
.rise-tab-btn{
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif;
  font-size: 12px; letter-spacing:.2px; font-weight:700;
  padding:.45rem .7rem; border-radius:10px; border:1px solid rgba(255,255,255,.08);
  color:#bdefff; background: linear-gradient(180deg, rgba(28,75,95,.6), rgba(22,36,48,.6));
  cursor:pointer; transition: all .18s ease;
}
.rise-tab-btn:hover{ transform: translateY(-1px); box-shadow: 0 6px 16px rgba(0,0,0,.35); }
.rise-tab-btn.is-active{ color:#02191f; background: linear-gradient(180deg, #79e7ff, #2cd1f0); }

/* Overlay panel */
#rise-admin-overlay{
  position: fixed; inset:0; z-index: 9998; display:none;
  background: radial-gradient(1200px 600px at 80% -10%, rgba(39,147,182,.16), transparent 60%),
              radial-gradient(800px 500px at -20% 120%, rgba(80,180,160,.12), transparent 60%),
              #08141b;
}
#rise-admin-overlay.rise-open{ display:block; }
.rise-admin-shell{ position:absolute; inset:64px 24px 24px 24px; display:flex; gap:18px; }
.rise-admin-left{ flex:1.25; overflow:auto; padding:18px; border-radius:14px;
  background: rgba(11,25,33,.65); border:1px solid rgba(255,255,255,.06); }
.rise-admin-right{ width: 470px; overflow:auto; padding:18px; border-radius:14px;
  background: rgba(11,25,33,.65); border:1px solid rgba(255,255,255,.06); }

.rise-panel-title{ font-size:14px; font-weight:900; color:#e3fbff; letter-spacing:.35px; margin: 2px 0 10px; }
.rise-desc{ color:#9ad6e6; font-size:12.5px; line-height:1.55; }
.rise-hr{ height:1px; background: linear-gradient(90deg, transparent, rgba(255,255,255,.10), transparent); margin:14px 0; }

/* Grid is single-column to guarantee full-width sliders */
.rise-grid{ display:grid; grid-template-columns: 1fr; gap:12px; }
.rise-knob{ display:flex; flex-direction:column; gap:8px; padding:8px 10px; border:1px solid rgba(255,255,255,.06); border-radius:10px;
  background: rgba(255,255,255,.02); }
.rise-knob label{ font-size:12px; color:#c7f4ff; font-weight:800; letter-spacing:.3px; }
.rise-note{ font-size:12px; color:#83b8c7; }
.rise-value{ font-size:12px; color:#bff6ff; font-weight:700; }

/* Sliders all full width */
.rise-slider{ -webkit-appearance:none; width:100%; height:8px; border-radius:8px; background:#163241; outline:none; }
.rise-slider::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:18px; height:18px; border-radius:50%;
  background:#7ff1ff; border:2px solid #0b1f28; box-shadow: 0 0 10px rgba(127,241,255,.5); cursor:pointer; }

/* Row tags on right pane */
.rise-tag{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
  background: rgba(24,201,217,.12); border:1px solid rgba(24,201,217,.35); color:#9ff7ff; font-size:11px; font-weight:800; }
.rise-kv{ display:flex; justify-content:space-between; gap:10px; padding:8px 0; border-bottom:1px dashed rgba(255,255,255,.06);
  color:#aad9e6; font-size:12px; }
.rise-kv b{ color:#e8feff; }

/* ==== Admin UI readability tweaks (v8) ==== */
/* Narrower, more readable left pane; right pane unchanged */
.rise-admin-shell{ gap:22px; }
.rise-admin-left{ flex: 0 0 760px; max-width: 760px; }
.rise-admin-right{ width: 470px; }

/* Each knob card constrained and centered */
.rise-grid{ grid-template-columns: 1fr; }
.rise-knob{ max-width: 720px; margin: 0 auto; }

/* Slider visual polish + glow */
.rise-slider{ height:10px; border-radius:999px; background: linear-gradient(90deg,#0f2c3a,#1a4457); box-shadow: inset 0 0 8px rgba(0,0,0,.35); }
.rise-slider:hover{ filter: brightness(1.05); box-shadow: inset 0 0 10px rgba(0,0,0,.42), 0 0 8px rgba(121,231,255,.15); }
.rise-slider:focus{ outline: none; box-shadow: inset 0 0 10px rgba(0,0,0,.42), 0 0 10px rgba(121,231,255,.22); }
.rise-slider::-webkit-slider-thumb{
  width:18px; height:18px; border-radius:50%;
  background:#9bf5ff; border:2px solid #0b1f28;
  box-shadow: 0 0 10px rgba(127,241,255,.50), 0 0 18px rgba(56,217,232,.35);
  transition: box-shadow .15s ease, transform .12s ease;
}
.rise-slider:hover::-webkit-slider-thumb{ box-shadow: 0 0 12px rgba(127,241,255,.70), 0 0 22px rgba(56,217,232,.45); transform: scale(1.05); }
.rise-slider:active::-webkit-slider-thumb{ box-shadow: 0 0 14px rgba(127,241,255,.90), 0 0 26px rgba(56,217,232,.60); transform: scale(1.08); }

/* Firefox thumb */
.rise-slider::-moz-range-thumb{
  width:18px; height:18px; border-radius:50%;
  background:#9bf5ff; border:2px solid #0b1f28;
  box-shadow: 0 0 10px rgba(127,241,255,.50), 0 0 18px rgba(56,217,232,.35);
  transition: box-shadow .15s ease, transform .12s ease;
}
.rise-slider:hover::-moz-range-thumb{ box-shadow: 0 0 12px rgba(127,241,255,.70), 0 0 22px rgba(56,217,232,.45); transform: scale(1.05); }
.rise-slider:active::-moz-range-thumb{ box-shadow: 0 0 14px rgba(127,241,255,.90), 0 0 26px rgba(56,217,232,.60); transform: scale(1.08); }

/* ==== Admin UI polish (v9) ==== */
/* Center the entire admin shell and set a max width */
.rise-admin-shell{
  position: absolute;
  top: 64px; bottom: 24px; left: 50%; transform: translateX(-50%);
  width: min(1380px, calc(100vw - 48px));
  display: flex; gap: 24px;
}

/* Panel widths for balanced reading */
.rise-admin-left{ flex: 0 0 760px; max-width: 760px; }
.rise-admin-right{ flex: 1; min-width: 520px; max-width: 600px; }

/* Consistent knob block layout (fix any offset issues like Payback knob) */
.rise-knob{ 
  max-width: 720px; margin: 0 auto; 
  display: grid; grid-template-columns: 1fr; gap: 8px;
}
.rise-knob label{ display:block; }
.rise-knob .rise-slider{ display:block; width:100%; }

/* Accents: titles and labels */
.rise-panel-title{
  color: #c3f5ff;
  text-transform: uppercase;
  letter-spacing: .06em;
  font-weight: 900;
  font-size: 13px;
  margin-bottom: 10px;
  text-shadow: 0 1px 0 rgba(0,0,0,.3);
}
/* Add a subtle accent underline */
.rise-panel-title::after{
  content:"";
  display:block;
  height:2px;
  margin-top:6px;
  background: linear-gradient(90deg, rgba(121,231,255,.85), rgba(34,211,238,.3), transparent);
  border-radius: 999px;
}

/* Knob labels with color accent */
.rise-knob label{
  color:#b6f0ff;
  font-weight: 800;
  text-shadow: 0 1px 0 rgba(0,0,0,.25);
}

/* Description readability */
.rise-desc{
  color:#a6ddea;
  line-height:1.6;
  font-size: 13px;
}

/* Slider glow already present; give track a tiny neon rim on focus */
.rise-slider:focus{ box-shadow: inset 0 0 10px rgba(0,0,0,.42), 0 0 12px rgba(121,231,255,.28); }

/* Right pane card readability */
.rise-admin-right{
  background: rgba(11,25,33,.7);
  border:1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  padding: 18px;
}

/* ==== High-contrast knob & badge pass (v10) ==== */
/* Knob track: deeper contrast + subtle neon */
.rise-slider{
  height: 12px;
  background: linear-gradient(90deg, #1a1030 0%, #0e2a37 100%);
  box-shadow: inset 0 0 12px rgba(0,0,0,.5), 0 0 6px rgba(121,231,255,.10);
  border-radius: 999px;
}
.rise-slider:hover{ filter: brightness(1.06); }
.rise-slider:focus{ box-shadow: inset 0 0 14px rgba(0,0,0,.55), 0 0 12px rgba(255,77,210,.18); }

/* Knob thumb: distinctive magenta w/ cyan bloom */
.rise-slider::-webkit-slider-thumb{
  width: 20px; height: 20px; border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #ff7fe3 0%, #ff4dd2 60%, #b3009a 100%);
  border: 2px solid #12081d;
  box-shadow: 0 0 12px rgba(255,77,210,.85), 0 0 26px rgba(44,209,240,.35);
  transition: transform .12s ease, box-shadow .15s ease, filter .12s ease;
}
.rise-slider:hover::-webkit-slider-thumb{ transform: scale(1.06); box-shadow: 0 0 14px rgba(255,77,210,.95), 0 0 30px rgba(44,209,240,.45); }
.rise-slider:active::-webkit-slider-thumb{ transform: scale(1.09); box-shadow: 0 0 18px rgba(255,77,210,1), 0 0 34px rgba(44,209,240,.55); }

/* Firefox thumb */
.rise-slider::-moz-range-thumb{
  width: 20px; height: 20px; border-radius: 50%;
  background: radial-gradient(circle at 40% 40%, #ff7fe3 0%, #ff4dd2 60%, #b3009a 100%);
  border: 2px solid #12081d;
  box-shadow: 0 0 12px rgba(255,77,210,.85), 0 0 26px rgba(44,209,240,.35);
  transition: transform .12s ease, box-shadow .15s ease, filter .12s ease;
}
.rise-slider:hover::-moz-range-thumb{ transform: scale(1.06); box-shadow: 0 0 14px rgba(255,77,210,.95), 0 0 30px rgba(44,209,240,.45); }
.rise-slider:active::-moz-range-thumb{ transform: scale(1.09); box-shadow: 0 0 18px rgba(255,77,210,1), 0 0 34px rgba(44,209,240,.55); }

/* Definition badges: brighter background, dark readable text, subtle glow */
.rise-tag{
  background: linear-gradient(180deg, #7be8ff 0%, #2cd1f0 100%);
  border: 1px solid rgba(2, 25, 31, .35);
  color: #041c23;
  font-weight: 900;
  font-size: 12.5px;
  box-shadow: 0 2px 10px rgba(44,209,240,.35), inset 0 0 0 rgba(255,255,255,0);
}

/* Panel titles: a bit more punch */
.rise-panel-title{
  color: #b9f6ff;
  text-shadow: 0 2px 10px rgba(44,209,240,.25);
}
.rise-panel-title::after{
  background: linear-gradient(90deg, rgba(255,77,210,.8), rgba(44,209,240,.5), transparent);
}

/* Knob labels: add accent */
.rise-knob label{
  color: #c9fbff;
  text-shadow: 0 1px 0 rgba(0,0,0,.3), 0 0 8px rgba(121,231,255,.15);
}

/* ==== Sanity & Primers dedicated panel (v12) ==== */
#rise-sanity-overlay{
  position: fixed; inset:0; z-index: 9998; display:none;
  background: radial-gradient(1200px 600px at 80% -10%, rgba(39,147,182,.16), transparent 60%),
              radial-gradient(800px 500px at -20% 120%, rgba(80,180,160,.12), transparent 60%),
              #08141b;
}
#rise-sanity-overlay.rise-open{ display:block; }
.rise-sanity-shell{
  position: absolute;
  top: 64px; bottom: 24px; left: 50%; transform: translateX(-50%);
  width: min(1200px, calc(100vw - 48px));
  display: grid; grid-template-columns: 1fr; gap: 16px;
}
.rise-card{
  background: rgba(11,25,33,.72);
  border:1px solid rgba(255,255,255,.08);
  border-radius: 14px;
  padding: 18px;
}
.rise-card h3{
  color:#b9f6ff; font-weight:900; letter-spacing:.05em; text-transform:uppercase; font-size:13px;
  margin:0 0 10px 0; text-shadow:0 2px 10px rgba(44,209,240,.25);
}
.rise-card h3::after{
  content:""; display:block; height:2px; margin-top:6px;
  background: linear-gradient(90deg, rgba(255,77,210,.8), rgba(44,209,240,.5), transparent);
  border-radius: 999px;
}
.rise-card .rise-desc{ font-size:13px; line-height:1.6; color:#a6ddea; }
.roi-pos{ color:#00ff9c; text-shadow:0 0 10px rgba(0,255,156,.6);}.roi-neg{ color:#ff33cc; text-shadow:0 0 10px rgba(255,51,204,.5);}</style><script>
// ==== RISE Tuning Knobs – injected (improved) ====
(function(){
  const KNOB_DEFAULTS = {
    CRR_TARGET: 0.80,
    OVERLAP_RULE_STRENGTH: 0.65,      // 0..1 (higher = stronger penalty when controls overlap)
    DIMINISHING_RETURNS_K: 0.75,      // 0..1 (higher = faster taper when stacking controls on the SAME failure)
    BENEFIT_SCALER_BASE: 1.00,        // scalar to tune overall annual benefit realism
    BENEFIT_WEIGHTS: {                // relative benefit weight by hierarchy
      PPE: 0.15, ADMIN: 0.25, SUB: 0.35, ENG: 0.65, ELIM: 1.00
    },
    MIX_BONUS_WEIGHT: 0.10,           // bonus (0–0.25) for balanced mixes (independent layers)
    MIX_MIN_UNIQUE_TYPES: 3,          // types needed to unlock full mix bonus
    NPV_DISCOUNT_RATE: 0.07,          // finance discount rate in NPV
    PAYBACK_CAP_MONTHS: 60,           // cap on payback value for display sanity
    ROI_NEG_THRESHOLD: 0.0            // < threshold = magenta, >= threshold = green
  };

  const state = {
    ...KNOB_DEFAULTS,
    ...(JSON.parse(localStorage.getItem('rise:tuningKnobs')||'{}'))
  };

  function save(){ localStorage.setItem('rise:tuningKnobs', JSON.stringify(state)); }
  function publish(){
    window.tuningKnobs = JSON.parse(JSON.stringify(state));
    window.dispatchEvent(new CustomEvent('tuning:updated', {detail: window.tuningKnobs}));
  }

  // Build header
  const header = document.createElement('div');
  header.className = 'rise-admin-header';
  header.innerHTML = `
    <button class="rise-tab-btn is-active" data-tab="dashboard">Dashboard</button>
    <button class="rise-tab-btn" data-tab="admin">Risk Mgmt Admin</button>
    <button class="rise-tab-btn" data-tab="sanity">Sanity & Primers</button>
  `;
  document.body.appendChild(header);

  // Overlay shell
  const overlay = document.createElement('div');
  overlay.id = 'rise-admin-overlay';
  overlay.innerHTML = `
    <div class="rise-admin-shell">
      <section class="rise-admin-left">
        <div class="rise-panel-title">Tuning Knobs</div>
        <div class="rise-desc">These controls adjust how the model values risk reduction and cost/benefit. Each explains in plain language what it affects and guidance on when to move it up or down.</div>
        <div class="rise-hr"></div>
        <div class="rise-grid" id="rise-knobs-grid"></div>
      </section>
      <aside class="rise-admin-right">
        <div class="rise-panel-title">What each knob does (quick guide)</div>
        <div class="rise-desc" id="rise-right-guide"></div>
        <div class="rise-hr"></div>
        <div class="rise-kv"><span>Settings storage</span><b>localStorage</b></div>
        <div class="rise-kv"><span>Broadcast</span><b>window.tuningKnobs + "tuning:updated"</b></div>
      </div>
      </aside>
    </div>
  `;
  document.body.appendChild(overlay);
  // Sanity & Primers overlay
  const sanity = document.createElement('div');
  sanity.id = 'rise-sanity-overlay';
  sanity.innerHTML = `
    <div class="rise-sanity-shell">
      <section class="rise-card">
        <h3>Sanity Testing Drills (Model Health)</h3>
        <div class="rise-desc">
          <p><b>Use these quick drills to confirm the model behaves as expected.</b></p>
          <ol>
            <li><b>Zero controls:</b> All toggles off ⇒ CRR ~ 0%, ROI ~ 0% (or negative if OPEX exists), NPV negative if any CAPEX exists.</li>
            <li><b>One cheap PPE on one failure:</b> Small CRR increase; ROI/NPV should move slightly but remain modest. No big jumps.</li>
            <li><b>Variety beats duplicates:</b> Compare two PPE on one failure vs. one Substitution + one Admin on the same failure. The mixed pair should yield <i>more</i> CRR than the PPE pair (overlap rule).</li>
            <li><b>Spread vs. stack:</b> Two controls on two different failures should generally outperform two controls stacked on a single failure (diminishing returns).</li>
            <li><b>Engineering/Elimination test:</b> Turn on one Engineering or Elimination control for a failure. CRR should rise meaningfully (hierarchy weights), and ROI/NPV should reflect higher effectiveness vs. cost.</li>
            <li><b>Discount sensitivity:</b> Keep the same portfolio; raise NPV discount from 7% → 12%. NPV should decrease (future savings valued less). ROI may change modestly; Payback months unchanged.</li>
            <li><b>Amortization sensitivity:</b> Increase CAPEX amortization years. Annual cost drops; ROI increases; NPV may improve (less penalty upfront).</li>
            <li><b>Benefit realism:</b> If field savings are known, tweak <i>Benefit Scaler</i> to align model outcomes (ROI/NPV/$-per-$) with real performance.</li>
          </ol>
          <p><b>Pass criteria:</b> Mixed, well-distributed portfolios trend toward higher CRR with reasonable ROI/NPV; duplicate-heavy stacks show diminishing benefit; high discount rates penalize late benefits as expected.</p>
        </div>
      </section>
      <section class="rise-card">
        <h3>Quick Primers</h3>
        <div class="rise-desc">
          <p><b>What are Overlap Rules?</b><br>
          A fairness rule so we don’t “double count” risk reduction when two or more controls cover the same weak spot in the failure path. 
          It keeps totals realistic: two PPE items on the same hazard don’t double the reduction. You get more credit from varied layers 
          (e.g., Substitution + Administrative) than duplicates (PPE + PPE).</p>

          <p><b>What is NPV (Net Present Value)?</b><br>
          A finance measure that converts future savings into today’s dollars using a discount rate, then subtracts costs. 
          <b>Positive NPV</b> means benefits outweigh costs overall (worth it). <b>Negative NPV</b> means they don’t (not worth it under current assumptions). 
          NPV is sensitive to up-front CAPEX, timing of benefits, and the discount rate.</p>

          <p><b>What is ROI?</b><br>
          A percent measure of return relative to cost over a period (here, annualized). Positive ROI means the program returns more than it costs within the period.</p>

          <p><b>What is Payback?</b><br>
          The time it takes for savings to equal the investment. Shorter is better. Payback doesn’t account for time value like NPV does, 
          so use them together: Payback for speed, NPV for overall worth.</p>
        </div>
      </section>
    </div>
  `;
  document.body.appendChild(sanity);


  const grid  = overlay.querySelector('#rise-knobs-grid');
  const guide = overlay.querySelector('#rise-right-guide');

  // Helper to add a slider block with description
  function addSlider(key, label, min, max, step, fmt, desc){
    const wrap = document.createElement('div'); wrap.className='rise-knob';
    const valueFmt = fmt || ((v)=>String(v));
    wrap.innerHTML = `
      <label>${label} — <span class="rise-value" id="val-${key}">${valueFmt(state[key])}</span></label>
      <input type="range" class="rise-slider" id="rng-${key}" min="${min}" max="${max}" step="${step}" value="${state[key]}"/>
      <div class="rise-note">${desc}</div>
    `;
    grid.appendChild(wrap);
    const rng = wrap.querySelector('#rng-'+key);
    const val = wrap.querySelector('#val-'+key);
    rng.addEventListener('input', ()=>{
      state[key] = Number(rng.value);
      val.textContent = valueFmt(state[key]);
      save(); publish();
    });
  }

  // Helper to add 0–1 weight row with desc
  function addWeight(hkey, label, desc){
    const wrap = document.createElement('div'); wrap.className='rise-knob';
    wrap.innerHTML = `
      <label>${label} — <span class="rise-value" id="val-W-${hkey}">${state.BENEFIT_WEIGHTS[hkey].toFixed(2)}</span></label>
      <input type="range" class="rise-slider" id="rng-W-${hkey}" min="0" max="1" step="0.01" value="${state.BENEFIT_WEIGHTS[hkey]}"/>
      <div class="rise-note">${desc}</div>
    `;
    grid.appendChild(wrap);
    const rng = wrap.querySelector('#rng-W-'+hkey);
    const val = wrap.querySelector('#val-W-'+hkey);
    rng.addEventListener('input', ()=>{
      state.BENEFIT_WEIGHTS[hkey] = Number(rng.value);
      val.textContent = state.BENEFIT_WEIGHTS[hkey].toFixed(2);
      save(); publish();
    });
  }

  // Build left panel controls (full-width)
  addSlider('CRR_TARGET','CRR Target (green threshold)', 0.50, 1.00, 0.01, v=> (v*100).toFixed(0)+'%',
    'Sets when CRR turns green. Higher = tougher bar; lower = easier early wins. Use 70–80% for pilots, 80–90% for steady ops. Affects how teams perceive progress on the main CRR tile. <b>Definition:</b> The target percent of total risk reduction where the CRR tile turns green. <b>Suggested ranges:</b> Pilots: 0.70–0.80; Mature sites: 0.80–0.90; Exceptionally controlled: ≥0.90.');

  addSlider('OVERLAP_RULE_STRENGTH','Overlap Rule Strength', 0.00, 1.00, 0.01, v=> v.toFixed(2),
    'Prevents double counting when controls overlap. Two PPE items on the same hazard rarely double the reduction. Increase to give less credit to duplicates; decrease only if duplicates are truly independent (e.g., two separate engineered interlocks). Helps the CRR and ROI tiles stay realistic. <b>Definition:</b> Overlap rules reduce credit when multiple controls cover the same failure path (to avoid inflated totals). <b>Suggested ranges:</b> 0.40–0.80 typical. Use higher values if duplicate stacking is common; lower if redundancies are proven independent.');

  addSlider('DIMINISHING_RETURNS_K','Diminishing Returns (stacking)', 0.00, 1.00, 0.01, v=> v.toFixed(2),
    'Each added control on the same failure matters less than the last. Turn up to spread investment across failures; turn down when one failure truly needs multiple layers. Works together with Overlap and Mix Bonus to steer balanced portfolios. <b>Definition:</b> A taper that reduces incremental benefit as more controls are stacked on a single failure. <b>Suggested ranges:</b> 0.50–0.85. Higher = faster taper; lower = gentler taper.');

  addSlider('BENEFIT_SCALER_BASE','Benefit Scaler (global realism)', 0.50, 2.00, 0.01, v=> v.toFixed(2),
    'Big-picture realism dial. If field savings are higher than the model, turn up; if lower or slower to appear, turn down. This adjusts ROI, NPV, Payback, and the $-per-$ gauge without changing every line item. <b>Definition:</b> A global multiplier on modeled annual benefits to align with field reality. <b>Suggested ranges:</b> 0.85–1.20. Use 1.00 as default; nudge ±10–15% based on observed results.');

  grid.appendChild(document.createElement('div')).className='rise-hr';

  // Hierarchy weights
  addWeight('PPE','PPE Weight',
    'PPE depends on human behavior. Keep low unless compliance is continuously monitored and fit/comfort are excellent. Raising this makes PPE contribute more to CRR and ROI. <b>Definition:</b> Relative weight of PPE effectiveness when translating SEI into realized reduction. <b>Suggested ranges:</b> 0.10–0.30 (default ~0.15). Only increase with strong compliance data.');
  addWeight('ADMIN','Administrative Weight',
    'Admin controls are training/SOPs/checks. Raise if automated and audited with low drift; lower if workarounds are common. This changes how much these controls move CRR, ROI, and Payback. <b>Definition:</b> Relative weight for Administrative controls (training, SOPs, checklists). <b>Suggested ranges:</b> 0.20–0.40 (default ~0.25).');
  addWeight('SUB','Substitution Weight',
    'Substitution swaps a material/method for a safer one. Keep medium-high if the substitute is stable and supply is reliable; lower if substitutes are fragile or create side-risks. Affects CRR and NPV realism. <b>Definition:</b> Relative weight for Substitution controls (safer materials/methods). <b>Suggested ranges:</b> 0.30–0.50 (default ~0.35).');
  addWeight('ENG','Engineering Control Weight',
    'Engineering controls (guards/interlocks/LEV) are usually reliable. Keep high, but reduce if maintenance/design quality varies. Heavier weight raises their impact on CRR and financials. <b>Definition:</b> Relative weight for Engineering controls (guards, interlocks, LEV). <b>Suggested ranges:</b> 0.55–0.80 (default ~0.65).');
  addWeight('ELIM','Elimination Weight',
    'Elimination (or full automation) removes the hazard or human exposure. This is the gold standard; reduce only if the so‑called elimination is partial, reversible, or operationally brittle.');

  grid.appendChild(document.createElement('div')).className='rise-hr';

  addSlider('MIX_BONUS_WEIGHT','Balanced Mix Bonus (max)', 0.00, 0.25, 0.01, v=> (v*100).toFixed(0)+'%',
    'Adds a bonus for building independent layers across hierarchy types. Increase to actively guide teams away from mono‑category portfolios (e.g., all training) toward resilient, layered defenses.');

  addSlider('MIX_MIN_UNIQUE_TYPES','Mix — Min Unique Types', 1, 5, 1, v=> v.toFixed(0),
    'Minimum distinct hierarchy categories to qualify for the full mix bonus. Three indicates a good baseline of variety; four or five pushes toward exceptional, defense‑in‑depth portfolios.');

  grid.appendChild(document.createElement('div')).className='rise-hr';

  addSlider('NPV_DISCOUNT_RATE','Finance: NPV Discount Rate', 0.00, 0.20, 0.005, v=> (v*100).toFixed(1)+'%',
    'Finance dial for time value: higher discounts shrink future benefits (conservative), lower discounts credit more value to later‑year gains. Align with corporate WACC or safety program risk appetite—commonly 5–10%.');

  addSlider('PAYBACK_CAP_MONTHS','Finance: Payback Cap (months)', 6, 120, 1, v=> v.toFixed(0)+' mo',
    'Display-only ceiling for long paybacks so charts stay readable. Math is unchanged; only the shown number is capped. <b>Definition:</b> Limits the maximum months displayed for payback to keep visuals readable. <b>Suggested ranges:</b> 36–84 months depending on portfolio. 60 months is a common cap.');

  addSlider('ROI_NEG_THRESHOLD','ROI Positive Threshold', -0.20, 0.20, 0.01, v=> (v*100).toFixed(0)+'%',
    'Where ROI flips from magenta (negative) to green (positive). Keep at 0% for neutral; set +5% if you want a safety margin before showing green. <b>Definition:</b> The visual threshold where ROI changes color in the dashboard. <b>Suggested ranges:</b> 0.00 for neutral; +0.05 if leadership wants a margin before green.');

  // Right pane quick guide: layman explanations
  guide.innerHTML = `
    <div class="rise-desc">
      <p><span class="rise-tag">CRR Target (Green Threshold)</span><br>
      <b>Plain English:</b> This is the goal line for total risk reduction. When the dashboard’s “CRR %” reaches this number, it turns green.<br>
      <b>Turn it up:</b> You’ll only see “green” when risk is pushed down further. Good for mature sites and big budgets.<br>
      <b>Turn it down:</b> Early pilots or tight budgets. Teams get credit for solid progress before perfection.<br>
      <b>Tip:</b> 70–80% for pilots, 80–90% for steady-state operations.</p>

      <p><span class="rise-tag">Overlap Rule Strength</span><br>
      <b>Plain English:</b> Prevents “double counting” when multiple controls protect the same weak spot. Two PPE items on one hazard rarely cut risk in half; they often overlap. Like the “Swiss cheese” idea, we want different slices, not two of the same slice.<br>
      <b>Example:</b> A <i>Substitution</i> plus an <i>Administrative</i> control usually reduces risk more than two cheap <i>PPE</i> items, because they block different failure paths.<br>
      <b>Turn it up:</b> Less credit for stacking similar controls (discourages “paper safety”).<br>
      <b>Turn it down:</b> If duplicates are genuinely independent (e.g., separate engineered interlocks), you can give them a bit more credit.<br>
      <b>Knob interactions:</b> Works with <i>Diminishing Returns</i> (controls on the same failure) and <i>Mix Bonus</i> (variety across hierarchy types) to shape fair, realistic totals.</p>

      <p><span class="rise-tag">Diminishing Returns (Stacking on One Failure)</span><br>
      <b>Plain English:</b> Each extra control on the same failure gives a little less benefit than the one before it. This steers teams to fix multiple failures instead of overspending on one.<br>
      <b>Turn it up:</b> Strong push to spread investment across different failures.<br>
      <b>Turn it down:</b> When one failure truly needs several layers (life-critical steps).<br>
      <b>Knob interactions:</b> Overlap and Diminishing Returns both reduce “overcrediting.” Use together to nudge teams toward balanced portfolios.</p>

      <p><span class="rise-tag">Benefit Scaler (Global Realism)</span><br>
      <b>Plain English:</b> Big-picture tuning. If your real-world savings are higher/lower than the model, use this to nudge the whole system up or down.<br>
      <b>Turn it up:</b> Incidents avoided or quality/uptime gains are consistently better than modeled.<br>
      <b>Turn it down:</b> If benefits take longer to show up or are smaller in practice.<br>
      <b>Knob interactions:</b> This influences ROI, NPV, Payback, and the “$ saved per $1 spent” gauge. Start here before editing individual control costs.</p>

      <p><span class="rise-tag">Hierarchy Weights (PPE, Admin, Sub, Eng, Elim)</span><br>
      <b>Plain English:</b> How much we trust each layer of the safety hierarchy to deliver real risk reduction. In practice: Elimination &gt; Engineering &gt; Substitution &gt; Administrative &gt; PPE.<br>
      <b>Adjust when:</b> Your site’s data proves a different order (e.g., automated admin checks beat your older engineering guards).<br>
      <b>Knob interactions:</b> These weights feed the “Swiss cheese” logic—varied layers counted more fairly than duplicates.</p>

      <p><span class="rise-tag">Balanced Mix Bonus</span><br>
      <b>Plain English:</b> Extra credit for using different types of controls together (e.g., one Substitution + one Engineering + one Admin). Variety blocks more holes in the cheese.<br>
      <b>Turn it up:</b> Encourage teams to avoid single-category portfolios (all training or all PPE).<br>
      <b>Turn it down:</b> When diversity is already strong or specialization is required.<br>
      <b>Knob interactions:</b> Complements Overlap/Diminishing—penalize duplicates, reward diversity.</p>

      <p><span class="rise-tag">Mix — Minimum Unique Types</span><br>
      <b>Plain English:</b> How many different control types you need before the full “mix bonus” kicks in.<br>
      <b>Guidance:</b> 3 = solid variety; 4–5 = excellent defense-in-depth.</p>

      <p><span class="rise-tag">Finance: NPV Discount Rate</span><br><b>Plain English:</b> How much we “shrink” future savings when valuing them today. A higher rate means money next year is worth less than money today, so long‑term savings get discounted more.<br><b>Turn it up (e.g., 10–12%):</b> When benefits are uncertain, back‑loaded, or depend on behavior change or long commissioning periods—this is more conservative and will reduce NPV.<br><b>Turn it down (e.g., 5–7%):</b> When benefits are mandated or very likely/near‑term (e.g., regulatory risk avoided immediately), which will increase NPV.<br><b>Quick example:</b> If a control saves $100k each year for 5 years, at 7% the present value of those savings is about $415k; at 12% it’s about $360k. NPV then subtracts up‑front CAPEX (and ongoing OPEX). With a high rate and a big up‑front cost, NPV can go negative even if the program eventually pays back.<br><b>How it interacts:</b> Works alongside <i>Amortization</i> (spreads CAPEX into annual cost), <i>Benefit Scaler</i> (nudges savings realism), and affects ROI, Payback, and the $‑per‑$ gauge. If NPV looks harsh but field results are strong, first check Benefit Scaler and Amortization before lowering the discount rate.<br><b>Typical ranges:</b> 5–10% (align with finance/WACC). Use the higher end for uncertainty and long lead times; lower end for stable, near‑certain safety gains.</p>

      <p><span class="rise-tag">Finance: Payback Cap (months)</span><br>
      <b>Plain English:</b> A display ceiling to keep charts readable for very long paybacks. Doesn’t change the math—just the number shown.</p>

      <p><span class="rise-tag">ROI Positive Threshold</span><br>
      <b>Plain English:</b> Where the ROI tile flips from magenta (bad/negative) to green (good/positive).<br>
      <b>Tip:</b> Leave at 0% for a neutral signal, or set to +5% if leaders want a buffer before showing green.</p>
    </div>
  `;

  // Tab behavior
  function setTab(tab){
    const btns = header.querySelectorAll('.rise-tab-btn');
    btns.forEach(b=> b.classList.toggle('is-active', b.dataset.tab===tab));
    if(tab==='admin'){ overlay.classList.add('rise-open'); sanity.classList.remove('rise-open'); }
    else if(tab==='sanity'){ sanity.classList.add('rise-open'); overlay.classList.remove('rise-open'); }
    else{ overlay.classList.remove('rise-open'); sanity.classList.remove('rise-open'); }
  }
  header.addEventListener('click', (e)=>{
    const b = e.target.closest('.rise-tab-btn'); if(!b) return;
    setTab(b.dataset.tab);
  });

  publish();
})();
</script>
<script>
(function(){
  function ensureAssistOverlays(){
    var assist = document.querySelector('.assist');
    if(!assist) return;
    if(!assist.querySelector('.assist-sweep')){
      var s = document.createElement('div');
      s.className = 'assist-sweep';
      assist.appendChild(s);
    }
    if(!assist.querySelector('.assist-corner-shadow')){
      var c = document.createElement('div');
      c.className = 'assist-corner-shadow';
      assist.appendChild(c);
    }
  }

  // Attempt to re-run guidance after any toggle/slider/select interaction.
  // We look for a known recompute function; if absent, we re-fire change on coverage meta to trigger existing listeners.
  function softRefresh(){
    try {
      if (typeof window.updateControlModel === 'function') {
        window.updateControlModel();
      } else if (typeof window.recomputeDashboard === 'function') {
        window.recomputeDashboard();
      } else if (typeof window.updateTiles === 'function') {
        window.updateTiles();
      } else {
        // fallback: dispatch a change event on the document to tick any on-change handlers
        var evt = new Event('change', {bubbles:true});
        document.dispatchEvent(evt);
      }
    } catch(e){ /* no-op */ }
  }

  function bindGlobalRefreshers(){
    var root = document;
    ['change','input','click'].forEach(function(ev){
      root.addEventListener(ev, function(e){
        // Only pay attention to control model UI regions
        var t = e.target;
        if(!t) return;
        var id = (t.id||'') + ' ' + (t.className||'');
        if(/toggle|select|knob|slider|checkbox|radio|control|hierarchy|failure/i.test(id)){
          softRefresh();
        }
      }, true);
    });
  }

  // DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ ensureAssistOverlays(); bindGlobalRefreshers(); });
  } else {
    ensureAssistOverlays(); bindGlobalRefreshers();
  }
})();
</script>


<script>
(function(){

  // --- helpers --------------------------------------------------------------
  function txt(el){ return (el && (el.textContent||"")).trim(); }
  function numFrom(text, re, dflt=null){
    if(!text) return dflt;
    var m = text.replace(/[\u202F,\s]/g,'').match(re);
    return m ? parseFloat(m[1]) : dflt;
  }
  function findNumberByLabel(labelRegex){
    // search tiles for a label that matches and try to grab a number near it
    var tiles = Array.from(document.querySelectorAll('.tile, .card, .panel, [data-tile]'));
    for (var t of tiles){
      var s = txt(t);
      if(labelRegex.test(s)){
        // prefer percentages
        var m = s.match(/(-?\d+(?:\.\d+)?)\s*%/);
        if(m) return parseFloat(m[1]);
        // else dollar or numeric
        m = s.match(/\$?\s*(-?\d+(?:\.\d+)?)/);
        if(m) return parseFloat(m[1]);
      }
    }
    return null;
  }
  function getCRR(){
    // Try common IDs first
    var el = document.querySelector('#crr, #crrPct, #crr_percent, [data-metric="crr"]');
    var v = numFrom(txt(el), /(-?\d+(?:\.\d+)?)/);
    if(v!=null) return v;
    // search by label
    v = findNumberByLabel(/CRR|Risk\s*Reduction|Cumulative\s*Risk/i);
    return v;
  }
  function getRoi(){
    var el = document.querySelector('#annualRoi, #roiAnnual, [data-metric="roi"]');
    var v = numFrom(txt(el), /(-?\d+(?:\.\d+)?)/);
    if(v!=null) return v;
    return findNumberByLabel(/Annual\s*ROI|ROI\b/i);
  }
  function getNpv(){
    var el = document.querySelector('#npv, [data-metric="npv"]');
    var t = txt(el);
    var v = numFrom(t, /\$?\s*(-?\d+(?:\.\d+)?)/);
    if(v!=null) return v;
    return findNumberByLabel(/\bNPV\b|Net\s*Present\s*Value/i);
  }
  function getRoiThreshold(){
    // try a known knob readout or data- attribute
    var el = document.querySelector('#roiThresholdKnob, [data-knob="roi_threshold"], .roi-threshold-chip');
    var v = numFrom(txt(el), /(-?\d+(?:\.\d+)?)/);
    return (v!=null)? v : 0; // default 0%
  }
  function getCrrTarget(){
    var el = document.querySelector('#crrTargetKnob, [data-knob="crr_target"], .crr-target-chip');
    var v = numFrom(txt(el), /(-?\d+(?:\.\d+)?)/);
    return (v!=null)? v : 80; // default 80%
  }

  function collectControls(){
    // Attempt to detect toggle panel structure
    var toggles = Array.from(document.querySelectorAll('[data-control], .control-toggle, input[type="checkbox"], input[type="radio"]'));
    var controls = [];
    toggles.forEach(function(el){
      // skip non-relevant inputs
      if(el.type && !/checkbox|radio/i.test(el.type)) return;
      var on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      // infer attributes
      var hierarchy = el.getAttribute('data-hierarchy') || el.getAttribute('data-type') || el.name || '';
      hierarchy = (hierarchy.match(/elimination|engineering|substitution|administrative|ppe/i)||['unknown'])[0].toLowerCase();
      var failureId = el.getAttribute('data-failure') || el.closest('[data-failure-id]')?.getAttribute('data-failure-id') || el.closest('[data-failure]')?.getAttribute('data-failure') || null;
      // cost
      var cost = parseFloat(el.getAttribute('data-cost')||'NaN');
      if(isNaN(cost)){
        // try to parse from nearby label
        var s = txt(el.closest('label')) || txt(el.parentElement);
        var m = s.replace(/[\u202F,]/g,'').match(/\$\s*(\d+(?:\.\d+)?)/);
        cost = m? parseFloat(m[1]) : 0;
      }
      if(failureId==null){
        // attempt to infer index by row grouping
        var grp = el.closest('[data-failure-group], .failure-row, .failure-card');
        failureId = grp ? (grp.getAttribute('data-failure-group') || grp.getAttribute('data-id') || Array.from(document.querySelectorAll('[data-failure-group], .failure-row, .failure-card')).indexOf(grp)) : null;
      }
      controls.push({el, on, hierarchy, failureId, cost});
    });
    return controls;
  }

  function computeIndependence(controls){
    // independence: for each failure, count unique hierarchy types among active controls; scale to [0,1]
    var byFail = {};
    controls.forEach(c=>{
      if(!c.on || !c.failureId) return;
      byFail[c.failureId] = byFail[c.failureId] || new Set();
      byFail[c.failureId].add(c.hierarchy);
    });
    var fails = Object.keys(byFail);
    if(fails.length===0) return {score:0, explain:"No active controls"};
    var maxLayers = 5; // elimination, engineering, substitution, administrative, ppe
    var sum = 0;
    fails.forEach(fid=> sum += Math.min(byFail[fid].size, maxLayers)/maxLayers );
    var score = sum / fails.length; // 0..1
    return {score, explain: fails.length+" failures with controls; avg unique layers/failure: "+(sum/fails.length*maxLayers).toFixed(1)};
  }

  function computeCoverage(controls){
    // failures with at least one control
    var allFids = new Set();
    controls.forEach(c=>{ if(c.failureId!=null) allFids.add(String(c.failureId)); });
    var covered = new Set();
    controls.forEach(c=>{ if(c.on && c.failureId!=null) covered.add(String(c.failureId)); });
    var total = allFids.size || covered.size;
    var pct = total ? (covered.size/total*100) : 0;
    return {pct, covered:covered.size, total};
  }

  function computeBudgetMix(controls){
    var on = controls.filter(c=>c.on);
    var sum = on.reduce((a,c)=>a+(c.cost||0),0);
    var byType = {elimination:0, engineering:0, substitution:0, administrative:0, ppe:0, unknown:0};
    on.forEach(c=> byType[c.hierarchy in byType? c.hierarchy : 'unknown'] += (c.cost||0));
    var toPct = (v)=> sum>0 ? Math.round(v/sum*100) : 0;
    return {
      total: sum,
      pct: {
        elimination: toPct(byType.elimination),
        engineering: toPct(byType.engineering),
        substitution: toPct(byType.substitution),
        administrative: toPct(byType.administrative),
        ppe: toPct(byType.ppe),
        unknown: toPct(byType.unknown)
      }
    };
  }

  
function updateAssist() {
  try {
    // Safe getters for dual-ID markup (legacy/new)
    const pick = (a,b) => document.getElementById(a) || document.getElementById(b);
    const setText = (a,b,txt) => { const el = pick(a,b); if(el) el.textContent = txt; };
    const setBadge = (a,b,cls) => { const el = pick(a,b); if(!el) return; el.className = el.className.replace(/\b(state--\w+)\b/g,''); if(cls) el.classList.add(cls); };

    // Gather current selection snapshot from in‑memory data (single source of truth)
    const sel = (typeof data!=='undefined' ? data.filter(d=>d.selected) : []);
    const perFail = sel.reduce((acc,r)=>{ acc[r.failure]=(acc[r.failure]||0)+1; return acc; },{});

    // Independence score = failures with >=1 control divided by total unique failures in dataset
    const totalFails = [...new Set((typeof data!=='undefined'? data.map(d=>d.failure):[]))].length || 1;
    const coveredFails = Object.keys(perFail).length;
    const independence = coveredFails / totalFails;

    // Budget mix = share of CAPEX vs OPEX for selected items
    const opex = sel.filter(r=>r.type==='OPEX').reduce((a,b)=>a+b.cost,0);
    const capex = sel.filter(r=>r.type==='CAPEX').reduce((a,b)=>a+b.cost,0);
    const mixPct = (capex+opex)>0 ? capex/(capex+opex) : 0; // using CAPEX share as the signal

    // Simple narratives
    const indepHint = independence>=0.9 ? 'Great coverage across failures.' :
                       independence>=0.66 ? 'Good spread; a few gaps remain.' :
                       independence>0 ? 'Concentrated on a few failures — add coverage.' :
                       'No coverage yet — begin with one control per failure.';

    const budgetHint = (capex+opex)===0 ? 'No spend yet.' :
      mixPct>0.75 ? 'Heavy CAPEX. Consider shifting some spend to lower OPEX items.' :
      mixPct<0.25 ? 'Heavy OPEX. If risk persists, add a few CAPEX/engineering items.' :
      'Balanced mix of CAPEX/OPEX.';

    // Write to Assist panel (handles both legacy/new IDs)
    setText('indepText','assist-independence', `${Math.round(independence*100)}% — ${indepHint}`);
    setText('budgetText','assist-budget-mix', `${Math.round(mixPct*100)}% CAPEX — ${budgetHint}`);

    // Probability: very rough proxy using average SEI of selection
    const avgSEI = sel.length? Math.round(sel.reduce((a,b)=>a+b.sei,0)/sel.length):0;
    setText('probText','assist-probability', `${avgSEI}% (proxy)`);

    // Recommendation & Next Step hooks already computed elsewhere; keep if present
    if (typeof computeRecommendation==='function') {
      setText('recText','assistRecommendation', computeRecommendation(sel, independence, mixPct));
    }
    if (typeof computeNextStep==='function') {
      setText('nextText','assistNext', computeNextStep(sel, independence, mixPct));
    }
  } catch (e) {
    console.warn('Assist update failed', e);
  }
}


  // hook into existing recompute paths and global interactions
  var origUpdate = window.updateControlModel;
  window.updateControlModel = function(){
    if(typeof origUpdate === 'function'){ try{ origUpdate(); }catch(e){} }
    updateAssist();
  };

  ['DOMContentLoaded','load'].forEach(evt=>window.addEventListener(evt, updateAssist));
  ['change','input','click'].forEach(ev=>document.addEventListener(ev, function(e){
    var t = e.target; if(!t) return;
    var hint = (t.id||'') + ' ' + (t.className||'') + ' ' + (t.name||'');
    if(/toggle|select|knob|slider|checkbox|radio|control|hierarchy|failure|assist/i.test(hint)){
      updateAssist();
    }
  }, true));

  // Initial kick
  setTimeout(updateAssist, 50);
})();
</script>


<script>
(function(){
  function setHTML(id, html){ var el=document.getElementById(id); if(el) el.innerHTML = html; }
  window._assistSetHTML = setHTML;
})();
</script>


<script>
(function(){
  // --- tiny utils ---
  const $ = (sel, root=document)=>root.querySelector(sel);
  const txt = (el)=> (el && (el.textContent||"")).trim();
  const num = (s)=>{
    if(!s) return null;
    s = s.replace(/[\$,%\u202F,\s]/g,'').trim();
    if(!s) return null;
    const v = parseFloat(s);
    return isNaN(v)? null : v;
  };

  // canonical element IDs we saw in this file
  function getCRR(){
    // prefer the big CRR number tile
    let v = num(txt($('#crrBig'))) ?? null;
    if(v!==null) return v;
    // fallback searches
    const cands = ['#crr','#crrPct','[data-metric="crr"]'];
    for(const c of cands){ const el=$(c); const x=num(txt(el)); if(x!==null) return x; }
    // scan tiles text
    const t = Array.from(document.querySelectorAll('.tile,.card,[data-tile]'))
      .map(n=>txt(n)).join(' ');
    const m = t.match(/CRR[^0-9\-]*(-?\d+(?:\.\d+)?)\s*%/i);
    return m? parseFloat(m[1]) : null;
  }
  function getROI(){
    let v = num(txt($('#fin-roi'))) ?? null;
    if(v!==null) return v;
    const cands = ['#annualRoi','#roiAnnual','[data-metric="roi"]'];
    for(const c of cands){ const el=$(c); const x=num(txt(el)); if(x!==null) return x; }
    return null;
  }
  function getNPV(){
    let raw = txt($('#fin-npv'));
    let v = num(raw);
    if(v!==null) return (/-/.test(raw)? -Math.abs(v): v); // keep sign if shown with '-'
    const el = $('#npv,[data-metric="npv"]');
    v = num(txt(el));
    return v;
  }
  function getKnobValue(selector, defVal){
    const el = $(selector);
    let v = num(txt(el));
    if(v===null && el && el.getAttribute('data-value')) v = num(el.getAttribute('data-value'));
    return (v===null? defVal : v);
  }
  function getTargets(){
    const roiThresh = getKnobValue('#roiThresholdKnob,.roi-threshold-chip,[data-knob="roi_threshold"]', 0);
    const crrTarget = getKnobValue('#crrTargetKnob,.crr-target-chip,[data-knob="crr_target"]', 80);
    return {roiThresh, crrTarget};
  }

  // collect toggled controls (best-effort)
  function collectControls(){
    const toggles = Array.from(document.querySelectorAll('[data-control], .control-toggle, input[type="checkbox"], input[type="radio"]'));
    const out = [];
    for(const el of toggles){
      if(el.type && !/checkbox|radio/i.test(el.type)) continue;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      let hierarchy = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
      let m = hierarchy.match(/elimination|engineering|substitution|administrative|ppe/);
      hierarchy = m? m[0] : 'unknown';
      let failureId = el.getAttribute('data-failure') ||
        (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
        (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;
      // cost
      let cost = num(el.getAttribute('data-cost'));
      if(cost===null){
        let lab = el.closest('label') || el.parentElement;
        if(lab){ const mm = (txt(lab).match(/\$\s*([\d,\.]+)/)||[])[1]; cost = num(mm); }
      }
      out.push({on,hierarchy,failureId,cost:cost||0});
    }
    return out;
  }

  function computeIndependence(controls){
    const byF = new Map();
    for(const c of controls){
      if(!c.on || c.failureId==null) continue;
      const key = String(c.failureId);
      if(!byF.has(key)) byF.set(key, new Set());
      byF.get(key).add(c.hierarchy);
    }
    const maxLayers = 5;
    if(byF.size===0) return {pct:0, explain:"No active controls"};
    let sum=0;
    for(const L of byF.values()) sum += Math.min(L.size, maxLayers)/maxLayers;
    const pct = Math.round( (sum/byF.size) * 100 );
    const avgLayers = (sum/byF.size*maxLayers).toFixed(1);
    return {pct, explain:`${byF.size} failures with controls; avg unique layers/failure: ${avgLayers}`};
  }
  function computeCoverage(controls){
    const all = new Set(), cov = new Set();
    controls.forEach(c=>{ if(c.failureId!=null) all.add(String(c.failureId)); if(c.on && c.failureId!=null) cov.add(String(c.failureId)); });
    const total = all.size || cov.size;
    const pct = total? Math.round(cov.size/total*100) : 0;
    return {pct, covered: cov.size, total};
  }
  function computeBudgetMix(controls){
    const on = controls.filter(c=>c.on);
    const sum = on.reduce((a,c)=>a+(c.cost||0),0);
    const keys = ['elimination','engineering','substitution','administrative','ppe','unknown'];
    const by = Object.fromEntries(keys.map(k=>[k,0]));
    on.forEach(c=> by[(c.hierarchy in by)? c.hierarchy : 'unknown'] += (c.cost||0));
    const toPct=(v)=> sum>0? Math.round(v/sum*100) : 0;
    return { total: sum, pct: Object.fromEntries(keys.map(k=>[k,toPct(by[k])])) };
  }

  function setHTML(id, html){ const el=document.getElementById(id); if(el) el.innerHTML=html; }

  function updateAssistHard(){
    const {roiThresh, crrTarget} = getTargets();
    const crr = getCRR();
    const roi = getROI();
    const npv = getNPV();

    const controls = collectControls();
    const coverage = computeCoverage(controls);
    const indep = computeIndependence(controls);
    const mix = computeBudgetMix(controls);

    // Independence
    const indepTone = indep.pct>=60 ? 'good' : (indep.pct>=35 ? 'warn' : 'bad');
    setHTML('independenceText', `<span class="${indepTone}">${indep.pct}%</span> <span class="mini">(${indep.explain})</span>`);

    // Next steps
    let next = "";
    if(coverage.total && coverage.covered < coverage.total){
      next = `Add at least one control to uncovered failures (${coverage.covered}/${coverage.total} covered).`;
    } else if (crr!=null && crr < crrTarget){
      next = `Increase CRR toward target (${Math.round(crr)}% → ${Math.round(crrTarget)}%). Favor higher-tier controls on the riskiest failure.`;
    } else if (roi!=null && roi < roiThresh){
      next = `Improve ROI (now ${Math.round(roi)}%). Shift spend to higher SEI-per-dollar.`;
    } else if (npv!=null && npv < 0){
      next = `NPV is negative. Trim high-capex or add quick wins to improve cash flow.`;
    } else {
      next = `Portfolio balanced—maintain coverage and tune for ROI.`;
    }
    setHTML('nextStepText', next);
    setHTML('recText', next);

    // Budget mix
    const bm=mix.pct;
    setHTML('budgetText', `ELM ${bm.elimination}% • ENG ${bm.engineering}% • SUB ${bm.substitution}% • ADM ${bm.administrative}% • PPE ${bm.ppe}% <span class="mini">(Total $${(mix.total||0).toLocaleString()})</span>`);

    // ROI guidance
    const roiTone = (roi!=null && roi>=roiThresh && (npv==null || npv>=0)) ? 'good' : ((roi!=null && roi>=0) ? 'warn':'bad');
    const roiSummary = (roi!=null? `${Math.round(roi)}% ROI` : '—');
    const npvFrag = (npv!=null ? ` · NPV ${npv<0?'<span class="bad">':'<span class="good">'}$${Math.abs(npv).toLocaleString()}</span>` : '');
    const tips = [];
    if (npv!=null && npv<0) tips.push("Reduce high-capex or extend horizon.");
    if (roi!=null && roi<roiThresh) tips.push("Favor higher SEI-per-dollar.");
    if (indep.pct<60) tips.push("Diversify types per failure (avoid duplicate PPE).");
    if (crr!=null && crr<crrTarget) tips.push("Prioritize top-tier controls on top-risk failure.");
    if (tips.length===0) tips.push("Economics healthy; keep mix balanced while meeting CRR.");
    setHTML('costText', `<span class="${roiTone}">${roiSummary}</span>${npvFrag}<div class="mini">• ${tips.join(' • ')}</div>`);

    // Probability (simple proxy from CRR vs target)
    if (crr!=null && crrTarget!=null){
      let p = Math.max(0, Math.min(100, Math.round((crr / Math.max(1, crrTarget)) * 100)));
      setHTML('probText', `Projected probability to achieve CRR ≥ ${Math.round(crrTarget)}%: <b>${p}%</b>`);
    }
  }

  // Attach robust triggers
  window.updateAssistHard = updateAssistHard;

  // Observe tiles area for changes (throttled)
  const throttle = (fn, ms)=>{
    let last=0, to=null;
    return ()=>{
      const now=Date.now();
      if(now-last>=ms){ last=now; fn(); }
      else { clearTimeout(to); to=setTimeout(()=>{ last=Date.now(); fn(); }, ms-(now-last)); }
    };
  };
  const safeTick = throttle(updateAssistHard, 120);

  const root = document.body;
  const obs = new MutationObserver(safeTick);
  obs.observe(root, {subtree:true, childList:true, characterData:true});

  // Also recompute on common interactions
  ['change','input','click'].forEach(ev=>document.addEventListener(ev, safeTick, true));

  // Initial kicks
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(updateAssistHard, 50); setTimeout(updateAssistHard, 350); });
  } else {
    setTimeout(updateAssistHard, 50);
    setTimeout(updateAssistHard, 350);
  }
})();
</script>


<script>
(function(){
  const $ = (s,root=document)=>root.querySelector(s);
  const txt = (el)=> (el && (el.textContent||'')).trim();
  const num = (s)=>{
    if(!s) return null;
    let raw = s.replace(/[\u202F,\s]/g,''); // remove thin spaces & commas
    let sign = (/^\s*-/.test(raw) ? -1 : 1);
    raw = raw.replace(/[$,%]/g,'');
    const v = parseFloat(raw);
    return isNaN(v)? null : sign*Math.abs(v);
  };
  const setHTML = (id, html)=>{ const el = document.getElementById(id); if(el) el.innerHTML = html; };

  function getCRR(){
    let v = num(txt($('#crrBig')));
    if(v!=null) return v;
    // fallback: look for percentage in any CRR tile text
    const t = Array.from(document.querySelectorAll('.tile,.card,[data-tile]')).map(n=>txt(n)).join(' ');
    const m = t.match(/CRR[^0-9\-]*(-?\d+(?:\.\d+)?)\s*%/i);
    return m? parseFloat(m[1]) : null;
  }
  function getROI(){
    let v = num(txt($('#fin-roi')));
    if(v!=null) return v;
    const m = (Array.from(document.querySelectorAll('.tile,.card')).map(n=>txt(n)).join(' ').match(/Annual\s*ROI[^0-9\-]*(-?\d+(?:\.\d+)?)\s*%/i)||[])[1];
    return m? parseFloat(m) : null;
  }
  function getNPV(){
    let raw = txt($('#fin-npv'));
    let v = num(raw);
    if(v!=null) return v;
    // fallback search for $… nearest to "NPV"
    const tiles = Array.from(document.querySelectorAll('.tile,.card'));
    for(const n of tiles){
      const s = txt(n);
      if(/NPV/i.test(s)){
        const mm = s.match(/\$?\s*(-?\d+(?:\.\d+)?)/);
        if(mm) return parseFloat(mm[1]);
      }
    }
    return null;
  }
  function knobVal(sel, defVal){
    const el = $(sel);
    let v = num(txt(el));
    if(v==null && el && el.getAttribute('data-value')) v = num(el.getAttribute('data-value'));
    return (v==null ? defVal : v);
  }

  function collectControls(){
    const toggles = Array.from(document.querySelectorAll('[data-control], .control-toggle, input[type="checkbox"], input[type="radio"]'));
    const out = [];
    for(const el of toggles){
      if(el.type && !/checkbox|radio/i.test(el.type)) continue;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      let hierarchy = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
      let mm = hierarchy.match(/elimination|engineering|substitution|administrative|ppe/);
      hierarchy = mm? mm[0] : 'unknown';
      let failureId = el.getAttribute('data-failure') ||
        (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
        (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;
      // cost
      let c = el.getAttribute('data-cost');
      let cost = num(c);
      if(cost==null){
        let lab = el.closest('label') || el.parentElement;
        if(lab){ const m = (txt(lab).match(/\$\s*([\d,\.]+)/)||[])[1]; cost = num(m); }
      }
      out.push({on, hierarchy, failureId, cost: (cost||0)});
    }
    return out;
  }

  function computeIndependence(controls){
    const byF = new Map();
    for(const c of controls){
      if(!c.on || c.failureId==null) continue;
      const key = String(c.failureId);
      if(!byF.has(key)) byF.set(key, new Set());
      byF.get(key).add(c.hierarchy);
    }
    const maxLayers=5;
    if(byF.size===0) return {pct:0, explain:"No active controls"};
    let sum=0;
    for(const L of byF.values()) sum += Math.min(L.size, maxLayers)/maxLayers;
    const pct = Math.round((sum/byF.size)*100);
    const avgLayers = (sum/byF.size*maxLayers).toFixed(1);
    return {pct, explain:`${byF.size} failures with controls; avg unique layers/failure: ${avgLayers}`};
  }
  function computeCoverage(controls){
    const all = new Set(), cov = new Set();
    for(const c of controls){
      if(c.failureId!=null) all.add(String(c.failureId));
      if(c.on && c.failureId!=null) cov.add(String(c.failureId));
    }
    const total = all.size || cov.size;
    const pct = total? Math.round(cov.size/total*100) : 0;
    return {pct, covered: cov.size, total};
  }
  function computeBudgetMix(controls){
    const on = controls.filter(c=>c.on);
    const sum = on.reduce((a,c)=>a+(c.cost||0),0);
    const keys = ['elimination','engineering','substitution','administrative','ppe','unknown'];
    const by = Object.fromEntries(keys.map(k=>[k,0]));
    on.forEach(c=> by[(c.hierarchy in by)? c.hierarchy : 'unknown'] += (c.cost||0));
    const toPct=(v)=> sum>0? Math.round(v/sum*100) : 0;
    return { total: sum, pct: Object.fromEntries(keys.map(k=>[k,toPct(by[k])])) };
  }

  function updateAssist(){
    const crr = getCRR();
    const roi = getROI();
    const npv = getNPV();
    const roiThresh = knobVal('#roiThresholdKnob,.roi-threshold-chip,[data-knob="roi_threshold"]', 0);
    const crrTarget = knobVal('#crrTargetKnob,.crr-target-chip,[data-knob="crr_target"]', 80);

    const controls = collectControls();
    const coverage = computeCoverage(controls);
    const indep = computeIndependence(controls);
    const mix = computeBudgetMix(controls);

    const indepTone = indep.pct>=60 ? 'good' : (indep.pct>=35 ? 'warn' : 'bad');
    setHTML('independenceText', `<span class="${indepTone}">${indep.pct}%</span> <span class="mini">(${indep.explain})</span>`);

    let next;
    if(coverage.total && coverage.covered < coverage.total){
      next = `Add at least one control to uncovered failures (${coverage.covered}/${coverage.total} covered).`;
    } else if (crr!=null && crr < crrTarget){
      next = `Increase CRR toward target (${Math.round(crr)}% → ${Math.round(crrTarget)}%). Favor higher-tier controls on the riskiest failure.`;
    } else if (roi!=null && roi < roiThresh){
      next = `Improve ROI (now ${Math.round(roi)}%). Shift spend to higher SEI-per-dollar.`;
    } else if (npv!=null && npv < 0){
      next = `NPV is negative. Trim high-capex or add quick wins to improve cash flow.`;
    } else {
      next = `Portfolio balanced—maintain coverage and tune for ROI.`;
    }
    setHTML('nextStepText', next);
    setHTML('recText', next);

    const bm = mix.pct;
    setHTML('budgetText', `ELM ${bm.elimination}% • ENG ${bm.engineering}% • SUB ${bm.substitution}% • ADM ${bm.administrative}% • PPE ${bm.ppe}% <span class="mini">(Total $${(mix.total||0).toLocaleString()})</span>`);

    const roiTone = (roi!=null && roi>=roiThresh && (npv==null || npv>=0)) ? 'good' : ((roi!=null && roi>=0) ? 'warn':'bad');
    const roiSummary = (roi!=null? `${Math.round(roi)}% ROI` : '—');
    const npvFrag = (npv!=null ? ` · NPV ${npv<0?'<span class="bad">':'<span class="good">'}$${Math.abs(npv).toLocaleString()}</span>` : '');
    const tips = [];
    if (npv!=null && npv<0) tips.push("Reduce high-capex or extend horizon.");
    if (roi!=null && roi<roiThresh) tips.push("Favor higher SEI-per-dollar.");
    if (indep.pct<60) tips.push("Diversify types per failure (avoid duplicate PPE).");
    if (crr!=null && crr<crrTarget) tips.push("Prioritize top-tier controls on top-risk failure.");
    if (tips.length===0) tips.push("Economics healthy; keep mix balanced while meeting CRR.");
    setHTML('costText', `<span class="${roiTone}">${roiSummary}</span>${npvFrag}<div class="mini">• ${tips.join(' • ')}</div>`);

    if (crr!=null && crrTarget!=null){
      let p = Math.max(0, Math.min(100, Math.round((crr / Math.max(1, crrTarget)) * 100)));
      setHTML('probText', `Projected probability to achieve CRR ≥ ${Math.round(crrTarget)}%: <b>${p}%</b>`);
    }
  }

  // events + mutation + periodic cadence
  const throttled = (()=>{
    let to=null, last=0;
    return function(){
      const now=Date.now();
      if(now-last>120){ last=now; updateAssist(); }
      else { clearTimeout(to); to=setTimeout(()=>{ last=Date.now(); updateAssist(); }, 120); }
    };
  })();

  ['change','input','click'].forEach(ev=>document.addEventListener(ev, throttled, true));
  const mo = new MutationObserver(throttled);
  mo.observe(document.body, {subtree:true, childList:true, characterData:true});

  // Fast polling for first 10s, then slow
  let ticks=0;
  const fast = setInterval(()=>{ updateAssist(); if(++ticks>20){ clearInterval(fast); }}, 500);
  setTimeout(()=>{ setInterval(updateAssist, 3000); }, 10000);

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(updateAssist, 80); });
  } else {
    setTimeout(updateAssist, 80);
  }
})();
</script>


<script>
(function(){
  const $ = (s,root=document)=>root.querySelector(s);
  const $$ = (s,root=document)=>Array.from(root.querySelectorAll(s));
  const txt = (el)=> (el && (el.textContent||'')).trim();
  const num = (s)=>{
    if(!s) return null;
    let raw = s.replace(/[\u202F,\u00A0,\,]/g,''); // thin/nbsp/comma
    let sign = (/^\s*-/.test(raw)? -1 : 1);
    raw = raw.replace(/[$%]/g,'');
    const v = parseFloat(raw);
    return isNaN(v)? null : sign*Math.abs(v);
  };
  const set = (ids, html)=> ids.forEach(id=>{ const el=document.getElementById(id); if(el) el.innerHTML = html; });

  function findByLabel(labelRegex){
    // scan visible tiles for label+value
    const blocks = $$('.tile, .card, .panel, [data-tile]');
    for(const b of blocks){
      const s = txt(b);
      if(labelRegex.test(s)){
        // prefer % first
        let m = s.match(/(-?\d+(?:\.\d+)?)\s*%/);
        if(m) return parseFloat(m[1]);
        // dollar / plain
        m = s.match(/\$?\s*(-?\d+(?:\.\d+)?)/);
        if(m) return parseFloat(m[1]);
      }
    }
    return null;
  }

  function getCRR(){
    // explicit ids first
    const explicit = ['#crrBig','#crr','#crrPct','[data-metric="crr"]'];
    for(const sel of explicit){ const v = num(txt($(sel))); if(v!=null) return v; }
    // label fallbacks
    return findByLabel(/CRR|Cumulative\s*Risk\s*Reduction|Risk\s*Reduction|Coverage/i);
  }
  function getROI(){
    const explicit = ['#fin-roi','#annualRoi','#roiAnnual','[data-metric="roi"]'];
    for(const sel of explicit){ const v = num(txt($(sel))); if(v!=null) return v; }
    return findByLabel(/Annual\s*ROI|ROI\b/i);
  }
  function getNPV(){
    // keep minus sign if present in text
    let el = $('#fin-npv'); 
    let raw = txt(el);
    let v = num(raw);
    if(v!=null) return v;
    el = $('#npv,[data-metric="npv"]');
    raw = txt(el);
    v = num(raw);
    if(v!=null) return v;
    // label fallback
    const blocks = $$('.tile, .card, .panel, [data-tile]');
    for(const b of blocks){
      const s = txt(b);
      if(/NPV|Net\s*Present\s*Value/i.test(s)){
        const m = s.match(/\$?\s*(-?\d+(?:\.\d+)?)/);
        if(m) return parseFloat(m[1]);
      }
    }
    return null;
  }
  function knobVal(selectors, defVal){
    for(const sel of selectors){
      const el = $(sel);
      if(!el) continue;
      let v = num(txt(el));
      if(v==null && el.getAttribute('data-value')) v = num(el.getAttribute('data-value'));
      if(v!=null) return v;
    }
    return defVal;
  }
  function collectControls(){
    const toggles = $$('[data-control], .control-toggle, input[type="checkbox"], input[type="radio"]');
    const out = [];
    for(const el of toggles){
      if(el.type && !/checkbox|radio/i.test(el.type)) continue;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      let h = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
      const mm = h.match(/elimination|engineering|substitution|administrative|ppe/);
      const hierarchy = mm? mm[0] : 'unknown';
      let failureId = el.getAttribute('data-failure') ||
        (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
        (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;
      let cost = num(el.getAttribute('data-cost'));
      if(cost==null){
        let lab = el.closest('label') || el.parentElement;
        if(lab){ const m = (txt(lab).match(/\$\s*([\d\.,]+)/)||[])[1]; cost = num(m); }
      }
      out.push({on, hierarchy, failureId, cost: (cost||0)});
    }
    return out;
  }
  function computeIndependence(controls){
    const byF = new Map();
    for(const c of controls){
      if(!c.on || c.failureId==null) continue;
      const key = String(c.failureId);
      if(!byF.has(key)) byF.set(key, new Set());
      byF.get(key).add(c.hierarchy);
    }
    const maxLayers=5;
    if(byF.size===0) return {pct:0, explain:"No active controls"};
    let sum=0;
    for(const L of byF.values()) sum += Math.min(L.size, maxLayers)/maxLayers;
    const pct = Math.round((sum/byF.size)*100);
    const avgLayers = (sum/byF.size*maxLayers).toFixed(1);
    return {pct, explain:`${byF.size} failures with controls; avg unique layers/failure: ${avgLayers}`};
  }
  function computeCoverage(controls){
    const all = new Set(), cov = new Set();
    for(const c of controls){
      if(c.failureId!=null) all.add(String(c.failureId));
      if(c.on && c.failureId!=null) cov.add(String(c.failureId));
    }
    const total = all.size || cov.size;
    const pct = total? Math.round(cov.size/total*100) : 0;
    return {pct, covered: cov.size, total};
  }
  function computeBudgetMix(controls){
    const on = controls.filter(c=>c.on);
    const sum = on.reduce((a,c)=>a+(c.cost||0),0);
    const keys = ['elimination','engineering','substitution','administrative','ppe','unknown'];
    const by = Object.fromEntries(keys.map(k=>[k,0]));
    on.forEach(c=> by[(c.hierarchy in by)? c.hierarchy : 'unknown'] += (c.cost||0));
    const toPct=(v)=> sum>0? Math.round(v/sum*100) : 0;
    return { total: sum, pct: Object.fromEntries(keys.map(k=>[k,toPct(by[k])])) };
  }

  function updateAssistAggressive(){
    const crr = getCRR();
    const roi = getROI();
    const npv = getNPV();
    const roiThresh = knobVal(['#roiThresholdKnob','.roi-threshold-chip','[data-knob="roi_threshold"]'], 0);
    const crrTarget = knobVal(['#crrTargetKnob','.crr-target-chip','[data-knob="crr_target"]'], 80);

    const controls = collectControls();
    const coverage = computeCoverage(controls);
    const indep = computeIndependence(controls);
    const mix = computeBudgetMix(controls);

    const indepTone = indep.pct>=60 ? 'good' : (indep.pct>=35 ? 'warn' : 'bad');
    set(['independenceText'], `<span class="${indepTone}">${indep.pct}%</span> <span class="mini">(${indep.explain})</span>`);

    let next;
    if(coverage.total && coverage.covered < coverage.total){
      next = `Add at least one control to uncovered failures (${coverage.covered}/${coverage.total} covered).`;
    } else if (crr!=null && crr < crrTarget){
      next = `Increase CRR toward target (${Math.round(crr)}% → ${Math.round(crrTarget)}%). Favor higher-tier controls on the riskiest failure.`;
    } else if (roi!=null && roi < roiThresh){
      next = `Improve ROI (now ${Math.round(roi)}%). Shift spend to higher SEI-per-dollar.`;
    } else if (npv!=null && npv < 0){
      next = `NPV is negative. Trim high-capex or add quick wins to improve cash flow.`;
    } else {
      next = `Portfolio balanced—maintain coverage and tune for ROI.`;
    }
    set(['nextStepText','recText'], next);

    const bm = mix.pct;
    set(['budgetText'], `ELM ${bm.elimination}% • ENG ${bm.engineering}% • SUB ${bm.substitution}% • ADM ${bm.administrative}% • PPE ${bm.ppe}% <span class="mini">(Total $${(mix.total||0).toLocaleString()})</span>`);

    const roiTone = (roi!=null && roi>=roiThresh && (npv==null || npv>=0)) ? 'good' : ((roi!=null && roi>=0) ? 'warn':'bad');
    const roiSummary = (roi!=null? `${Math.round(roi)}% ROI` : '—');
    const npvFrag = (npv!=null ? ` · NPV ${npv<0?'<span class="bad">':'<span class="good">'}$${Math.abs(npv).toLocaleString()}</span>` : '');
    const tips = [];
    if (npv!=null && npv<0) tips.push("Reduce high-capex or extend horizon.");
    if (roi!=null && roi<roiThresh) tips.push("Favor higher SEI-per-dollar.");
    if (indep.pct<60) tips.push("Diversify types per failure (avoid duplicate PPE).");
    if (crr!=null && crr<crrTarget) tips.push("Prioritize top-tier controls on top-risk failure.");
    if (tips.length===0) tips.push("Economics healthy; keep mix balanced while meeting CRR.");
    set(['costText'], `<span class="${roiTone}">${roiSummary}</span>${npvFrag}<div class="mini">• ${tips.join(' • ')}</div>`);

    if (crr!=null && crrTarget!=null){
      let p = Math.max(0, Math.min(100, Math.round((crr / Math.max(1, crrTarget)) * 100)));
      set(['probText'], `Projected probability to achieve CRR ≥ ${Math.round(crrTarget)}%: <b>${p}%</b>`);
    }
  }

  // expose and schedule
  window.updateAssistAggressive = updateAssistAggressive;
  // fast periodic updates every 400ms
  // disabled polling (assistAggressive)
  // also fire on basic interactions to be snappy
  ['change','input','click'].forEach(ev=>document.addEventListener(ev, updateAssistAggressive, true));
  // initial kick
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', updateAssistAggressive);
  } else {
    updateAssistAggressive();
  }
})();
</script>


<script>
// === Enhanced control scraping for Budget Mix & Independence ===
(function(){
  // Insert after the aggressive updater; override collectControls() if present
  function $$(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }
  function txt(el){ return (el && (el.textContent||"")).trim(); }
  function num(s){
    if(!s) return null;
    let raw = s.replace(/[\u202F\u00A0,]/g,''); // thin space, nbsp, commas
    let sign = (/^\s*-/.test(raw)? -1 : 1);
    raw = raw.replace(/[$%]/g,'');
    const v = parseFloat(raw);
    return isNaN(v)? null : sign*Math.abs(v);
  }

  // Heuristic: find all "failure sections" to index controls when dataset ids are absent
  function findFailureSections(){
    // look for obvious containers
    const candidates = $$('[data-failure-group],[data-failure-id],[data-failure], .failure-card, .failure-row, fieldset, section');
    // Filter to ones that contain multiple toggles
    const sections = candidates.filter(sec => $$('.control-toggle, [data-control], input[type="checkbox"], input[type="radio"]', sec).length >= 1);
    // De-duplicate while preserving order
    const out = [];
    const seen = new Set();
    for(const s of sections){
      if(seen.has(s)) continue;
      seen.add(s);
      out.push(s);
    }
    if(out.length) return out;

    // Fallback: group by nearest parents of each input; create unique roots by ascension
    const inputs = $$('input[type="checkbox"], input[type="radio"]');
    const roots = [];
    inputs.forEach(inp=>{
      let p = inp.parentElement;
      while(p && p !== document.body){
        if(p.matches('fieldset, section, .card, .panel, .tile')){ roots.push(p); break; }
        p = p.parentElement;
      }
    });
    // unique
    return roots.filter((v,i,a)=>a.indexOf(v)===i);
  }

  window.collectControls = function(){
    const toggles = $$('[data-control], .control-toggle, input[type="checkbox"], input[type="radio"]');
    const sections = findFailureSections();
    const controls = [];
    for(const el of toggles){
      if(el.type && !/checkbox|radio/i.test(el.type)) continue;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      let hierarchy = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
      let mm = hierarchy.match(/elimination|engineering|substitution|administrative|ppe/);
      hierarchy = mm? mm[0] : 'unknown';

      // explicit failure ID first
      let failureId = el.getAttribute('data-failure') ||
        (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
        (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;

      // else derive by section index
      if(failureId==null){
        let root = el.closest('[data-failure-group],[data-failure-id],[data-failure], .failure-card, .failure-row, fieldset, section');
        if(!root){
          // climb to a broader card/panel if needed
          let p = el.parentElement;
          while(p && p !== document.body){
            if(p.matches('.card,.panel,.tile,fieldset,section')){ root = p; break; }
            p = p.parentElement;
          }
        }
        if(root){
          let idx = sections.indexOf(root);
          if(idx === -1){
            // add to mapping if new
            sections.push(root);
            idx = sections.length - 1;
          }
          failureId = "auto_"+idx;
        }
      }

      // cost detection
      let cost = num(el.getAttribute('data-cost'));
      if(cost==null){
        // sibling with data-cost
        let sib = el.closest('label') || el.parentElement;
        if(sib){
          let ds = sib.getAttribute('data-cost') || (sib.querySelector('[data-cost]') && sib.querySelector('[data-cost]').getAttribute('data-cost')) || null;
          cost = num(ds);
          if(cost==null){
            // look for .cost class or $... in text nearby
            let cnode = sib.querySelector('.cost, .price, [class*="cost"]');
            if(cnode) cost = num(txt(cnode));
            if(cost==null){
              // try combined text
              cost = num((txt(sib).match(/\$\s*([\d\.,]+)/)||[])[1]);
            }
          }
        }
      }

      controls.push({on, hierarchy, failureId, cost: (cost||0)});
    }
    return controls;
  };

  // Force-run existing updater (if present) after override
  try{ if(typeof window.updateAssistAggressive === 'function'){ window.updateAssistAggressive(); } }catch(e){}
})();
</script>


<script>
/* ===== Ultra-robust control discovery + prescriptive guidance ===== */
(function(){
  const Q = (s,root=document)=>root.querySelector(s);
  const QA= (s,root=document)=>Array.from(root.querySelectorAll(s));
  const T = (el)=> (el && (el.textContent||'')).trim();
  const N = (s)=>{
    if(!s) return null;
    let raw = s.replace(/[\u202F\u00A0,\s]/g,'');
    const neg = /^\s*-/.test(raw);
    raw = raw.replace(/[$%]/g,'');
    const v = parseFloat(raw);
    return isNaN(v)? null : (neg? -Math.abs(v): Math.abs(v));
  };
  const contains = (el, rx)=> !!(el && rx.test(T(el)));

  // Heuristic weighting for tiers (for recommendations)
  const TIER_ORDER = ["elimination","engineering","substitution","administrative","ppe"];
  const TIER_SCORE = {elimination:5, engineering:4, substitution:3, administrative:2, ppe:1, unknown:0};

  function findToggleRoot(){
    // Try common ids/classes/names
    const guesses = [
      '#controlTogglePanel','#togglePanel','#control-model','#controls',
      '.control-model','.toggle-panel','.controls'
    ];
    for(const sel of guesses){ const n = Q(sel); if(n) return n; }
    // Fallback: pick the largest region with many checkboxes/radios
    const regions = QA('section,fieldset,.panel,.card,.tile,div');
    let best=null, score=0;
    for(const r of regions){
      const c = QA('input[type="checkbox"],input[type="radio"]', r).length;
      if(c>score){ score=c; best=r; }
    }
    return best || document.body;
  }

  // Try to parse the hierarchy type from any nearby text
  function inferHierarchy(el){
    const rx = /(elimination|engineering|substitution|administrative|ppe)/i;
    // direct attributes
    let s = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
    let m = s.match(rx); if(m) return m[1].toLowerCase();
    // aria-label / title
    s = (el.getAttribute('aria-label')||el.getAttribute('title')||'').toLowerCase();
    m = s.match(rx); if(m) return m[1].toLowerCase();
    // label text
    let lab = el.closest('label') || el.parentElement;
    s = (lab? T(lab).toLowerCase() : '');
    m = s.match(rx); if(m) return m[1].toLowerCase();
    return 'unknown';
  }

  // Try to find the dollar cost near a control
  function inferCost(el){
    // direct
    let c = el.getAttribute('data-cost');
    let v = N(c); if(v!=null) return v;
    // look up to two ancestor levels for a data-cost
    let p = el.parentElement, steps=0;
    while(p && steps<2){
      if(p.hasAttribute && p.hasAttribute('data-cost')){
        v = N(p.getAttribute('data-cost')); if(v!=null) return v;
      }
      const dataNode = p.querySelector && (p.querySelector('[data-cost], .cost, .price, [class*="cost"]'));
      if(dataNode){
        v = N(T(dataNode)); if(v!=null) return v;
        if(dataNode.getAttribute && dataNode.getAttribute('data-cost')){
          v = N(dataNode.getAttribute('data-cost')); if(v!=null) return v;
        }
      }
      // textual $123
      const m = T(p).match(/\$\s*([\d,\.]+)/);
      if(m){ v = N(m[1]); if(v!=null) return v; }
      p = p.parentElement; steps++;
    }
    return 0;
  }

  // Build failure sections by headings or structural containers
  function findFailureSections(root){
    // Priority 1: explicit attrs
    let secs = QA('[data-failure-group],[data-failure-id],[data-failure]', root);
    // Priority 2: headings that read like "Failure ..."
    if(secs.length===0){
      const heads = QA('h1,h2,h3,h4,h5,h6,legend', root).filter(h => /failure|hazard|event|scenario/i.test(T(h)));
      for(const h of heads){
        // group with next sibling container
        let container = h.parentElement;
        if(container) secs.push(container);
      }
    }
    // Priority 3: big cards that contain many control inputs
    if(secs.length===0){
      secs = QA('.failure-card,.failure-row, fieldset, section, .card, .panel, .tile', root)
             .filter(sec=> QA('input[type="checkbox"],input[type="radio"]', sec).length >= 1);
    }
    // Deduplicate while keeping order
    const seen = new Set(); const out=[];
    for(const s of secs){ if(!seen.has(s)){ seen.add(s); out.push(s); } }
    return out;
  }

  // Global collector (overrides any earlier one)
  window.collectControls = function(){
    const root = findToggleRoot();
    const sections = findFailureSections(root);
    const toggles = QA('input[type="checkbox"],input[type="radio"]', root);
    const controls = [];
    for(const el of toggles){
      const typeOK = !el.type || /checkbox|radio/i.test(el.type);
      if(!typeOK) continue;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true');
      const hierarchy = inferHierarchy(el);
      // Failure id: data-* or section index fallback
      let fid = el.getAttribute('data-failure') ||
                (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
                (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;
      if(fid==null){
        // find the nearest containing failure section from our list
        let nearest=null, nearestIdx=-1;
        let p=el.parentElement;
        while(p && p!==document.body){
          const idx = sections.indexOf(p);
          if(idx>=0){ nearest=p; nearestIdx=idx; break; }
          p=p.parentElement;
        }
        if(nearestIdx<0 && sections.length>0){
          // last resort: assign by document order proximity
          let bestDist=1e9, bestIdx=0;
          sections.forEach((sec,idx)=>{
            const dist = Math.abs(sec.getBoundingClientRect().top - el.getBoundingClientRect().top);
            if(dist<bestDist){ bestDist=dist; bestIdx=idx; }
          });
          nearestIdx = bestIdx;
        }
        fid = "auto_"+nearestIdx;
      }
      const cost = inferCost(el);
      controls.push({on, hierarchy, failureId: fid, cost});
    }
    return controls;
  };

  // Re-define independence & budget computations (idempotent)
  function computeIndependence(controls){
    const byF = new Map();
    for(const c of controls){
      if(!c.on || c.failureId==null) continue;
      const key = String(c.failureId);
      if(!byF.has(key)) byF.set(key, new Set());
      byF.get(key).add(c.hierarchy);
    }
    const maxLayers=5;
    if(byF.size===0) return {pct:0, explain:"No active controls"};
    let sum=0;
    for(const L of byF.values()) sum += Math.min(L.size, maxLayers)/maxLayers;
    const pct = Math.round((sum/byF.size)*100);
    const avgLayers = (sum/byF.size*maxLayers).toFixed(1);
    return {pct, explain:`${byF.size} failures with controls; avg unique layers/failure: ${avgLayers}`};
  }
  function computeBudgetMix(controls){
    const on = controls.filter(c=>c.on);
    const sum = on.reduce((a,c)=>a+(c.cost||0),0);
    const keys = ['elimination','engineering','substitution','administrative','ppe','unknown'];
    const by = Object.fromEntries(keys.map(k=>[k,0]));
    on.forEach(c=> by[(c.hierarchy in by)? c.hierarchy : 'unknown'] += (c.cost||0));
    const toPct=(v)=> sum>0? Math.round(v/sum*100) : 0;
    return { total: sum, pct: Object.fromEntries(keys.map(k=>[k,toPct(by[k])])) };
  }

  // Replace aggressive updater's body using our collector + smarter "Next steps"
  function upgradeAssist(){
    if(typeof window.updateAssistAggressive !== 'function') return;
    const orig = window.updateAssistAggressive;
    window.updateAssistAggressive = function(){};
      })();
      const indep = computeIndependence(controls);
      const mix = computeBudgetMix(controls);

      // Write Independence
      const tone = indep.pct>=60 ? 'good' : (indep.pct>=35 ? 'warn' : 'bad');
      const indepHTML = `<span class="${tone}">${indep.pct}%</span> <span class="mini">(${indep.explain})</span>`;
      const dest = document.getElementById('independenceText');
      if(dest) dest.innerHTML = indepHTML;

      // Write Budget Mix
      const bm = mix.pct;
      const bmHTML = `ELM ${bm.elimination}% • ENG ${bm.engineering}% • SUB ${bm.substitution}% • ADM ${bm.administrative}% • PPE ${bm.ppe}% <span class="mini">(Total $${(mix.total||0).toLocaleString()})</span>`;
      const bdest = document.getElementById('budgetText');
      if(bdest) bdest.innerHTML = bmHTML;

      // Smarter Next Step: prioritize concrete actions
      let next="";
      if(coverage.total && coverage.covered < coverage.total){
        const showFew = coverage.uncovered.slice(0,3).join(', ');
        next = `Cover gaps: add ≥1 control to uncovered failures (${coverage.covered}/${coverage.total} covered). Examples: ${showFew || '—'}.`;
      } else {
        // For each failure, if duplicate low-tier controls and missing higher tier, recommend diversify up the ladder
        const byF = {};
        controls.forEach(c=>{
          if(!byF[c.failureId]) byF[c.failureId] = {on:new Set(), all:[]};
          if(c.on) byF[c.failureId].on.add(c.hierarchy);
          byF[c.failureId].all.push(c);
        });
        // find a failure that lacks a high tier
        let targetF=null, suggestTier=null;
        for(const fid in byF){
          const have = byF[fid].on;
          for(const tier of TIER_ORDER){
            if(!have.has(tier)){ targetF=fid; suggestTier=tier; break; }
          }
          if(targetF) break;
        }
        if(targetF && suggestTier){
          const pretty = suggestTier.toUpperCase().slice(0,3);
          next = `Diversify: add ${suggestTier} on failure ${targetF} to strengthen layers.`;
        } else {
          // fallback to economics hints if available
          const roi = (function(el){ let v = N(T(Q('#fin-roi'))); return v; })();
          const npv = (function(el){ let s=T(Q('#fin-npv')); let v=N(s); return v; })();
          if(npv!=null && npv<0){
            next = `Improve economics: replace high-capex items with faster-payback controls; keep CRR ≥ target.`;
          } else if(roi!=null && roi<0){
            next = `Lift ROI: swap low SEI-per-$ controls for higher efficiency options.`;
          } else {
            next = `Portfolio looks balanced—fine tune weights and targets as needed.`;
          }
        }
      }
      const nDest = document.getElementById('nextStepText');
      if(nDest) nDest.textContent = next;
      const rec = document.getElementById('recText');
      if(rec) rec.textContent = next;
    };
  }

  // Activate upgrade after current scripts load
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', upgradeAssist);
  } else {
    upgradeAssist();
  }
})();
</script>


<script>
(function(){
  // Helpers
  const $ = (s,root=document)=>root.querySelector(s);
  const $$= (s,root=document)=>Array.from(root.querySelectorAll(s));
  const T = (el)=> (el && (el.textContent||'')).trim();

  function parseCostSplitTile(){
    // Try to find a tile/card mentioning "Cost Split" and parse tier percentages
    const blocks = $$('.tile,.card,.panel,[data-tile]');
    let text = "";
    for(const b of blocks){
      const s = T(b);
      if(/cost\s*split/i.test(s)){
        text = s; break;
      }
    }
    if(!text) return null;
    // Extract percentages keyed by tier labels
    function grab(rxLabel){
      const m = text.match(new RegExp(rxLabel+"[^0-9]*(\\d+(?:\\.\\d+)?)\\s*%","i"));
      return m ? Math.round(parseFloat(m[1])) : null;
    }
    const out = {
      elimination: grab("elimination|elm|elim"),
      engineering: grab("engineering|eng"),
      substitution: grab("substitution|sub"),
      administrative: grab("administrative|admin|adm"),
      ppe: grab("\\bppe\\b")
    };
    // Accept only if at least one is numeric
    if(Object.values(out).some(v=> v!==null)) return out;
    return null;
  }

  // Hook into our previous upgrade to add fallbacks
  function attachFallbacks(){
    if(typeof window.updateAssistAggressive !== 'function') return;
    const prior = window.updateAssistAggressive;
    window.updateAssistAggressive = function(){};
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', attachFallbacks);
  } else {
    attachFallbacks();
  }
})();
</script>


<script>
(function(){
  const $ = (s,root=document)=>root.querySelector(s);
  const $$= (s,root=document)=>Array.from(root.querySelectorAll(s));
  const T = (el)=> (el && (el.textContent||'')).trim();
  const N = (s)=>{
    if(!s) return null;
    let raw = s.replace(/[\u202F\u00A0,\s]/g,'');
    const neg = /^\s*-/.test(raw);
    raw = raw.replace(/[$%]/g,'');
    const v = parseFloat(raw);
    return isNaN(v)? null : (neg? -Math.abs(v): Math.abs(v));
  };

  const TIER_ORDER = ["elimination","engineering","substitution","administrative","ppe"];
  const HIER_RX = /(elimination|engineering|substitution|administrative|ppe)/i;

  // Internal control registry
  const REG = new Map();

  function inferHierarchyFrom(el){
    // attributes
    const a = (el.getAttribute('data-hierarchy')||el.getAttribute('data-type')||el.name||'').toLowerCase();
    let m = a.match(HIER_RX); if(m) return m[1].toLowerCase();
    // aria-label / title
    const b = (el.getAttribute('aria-label')||el.getAttribute('title')||'').toLowerCase();
    m = b.match(HIER_RX); if(m) return m[1].toLowerCase();
    // surrounding text
    let lab = el.closest('label') || el.parentElement;
    const s = (lab? T(lab).toLowerCase(): '');
    m = s.match(HIER_RX); if(m) return m[1].toLowerCase();
    // look up to two parents for a header containing the word
    let p = el.parentElement, steps=0;
    while(p && steps<2){
      const head = p.querySelector && p.querySelector('h1,h2,h3,h4,h5,h6,legend');
      if(head){
        const htxt = T(head).toLowerCase();
        m = htxt.match(HIER_RX); if(m) return m[1].toLowerCase();
      }
      p=p.parentElement; steps++;
    }
    return 'unknown';
  }

  function inferFailureFrom(el){
    // explicit
    let fid = el.getAttribute('data-failure') ||
              (el.closest('[data-failure-id]') && el.closest('[data-failure-id]').getAttribute('data-failure-id')) ||
              (el.closest('[data-failure]') && el.closest('[data-failure]').getAttribute('data-failure')) || null;
    if(fid) return String(fid);
    // nearest ancestor that has a header containing "Failure"
    let p = el.parentElement;
    while(p && p!==document.body){
      const head = p.querySelector && p.querySelector('h1,h2,h3,h4,h5,h6,legend');
      if(head && /failure|hazard|event|scenario/i.test(T(head))){
        // use its index among similar sections for stability
        const secs = $$('h1,h2,h3,h4,h5,h6,legend').filter(h=>/failure|hazard|event|scenario/i.test(T(h)));
        const idx = secs.indexOf(head);
        return "auto_"+(idx>=0? idx: 0);
      }
      p=p.parentElement;
    }
    // fallback: 0
    return "auto_0";
  }

  function inferCost(el){
    let v = N(el.getAttribute('data-cost'));
    if(v!=null) return v;
    let lab = el.closest('label') || el.parentElement;
    if(lab){
      // attribute on label or child
      const attr = lab.getAttribute('data-cost') || (lab.querySelector('[data-cost]') && lab.querySelector('[data-cost]').getAttribute('data-cost'));
      v = N(attr); if(v!=null) return v;
      // class cost/price
      const cnode = lab.querySelector('.cost, .price, [class*="cost"]');
      if(cnode){ v = N(T(cnode)); if(v!=null) return v; }
      // $xxx in text
      const mm = (T(lab).match(/\$\s*([\d,\.]+)/)||[])[1];
      v = N(mm); if(v!=null) return v;
    }
    // climb one parent
    const p = el.parentElement;
    if(p){
      const mm = (T(p).match(/\$\s*([\d,\.]+)/)||[])[1];
      v = N(mm); if(v!=null) return v;
    }
    return 0;
  }

  function buildRegistryOnce(){
    if(REG.size>0) return;
    const inputs = $$('input[type="checkbox"],input[type="radio"]');
    let idx=0;
    for(const el of inputs){
      if(!/checkbox|radio/i.test(el.type)) continue;
      const id = el.id || ("auto_ctl_"+(++idx));
      const rec = {
        id,
        node: el,
        failureId: inferFailureFrom(el),
        hierarchy: inferHierarchyFrom(el),
        cost: inferCost(el)
      };
      REG.set(id, rec);
      el.addEventListener('change', recomputeAssist, true);
    }
  }

  function activeControls(){
    buildRegistryOnce();
    const out=[];
    REG.forEach(rec=>{
      const el = rec.node;
      const on = !!el.checked || (el.getAttribute('aria-pressed')==='true') || el.classList.contains('active') || el.classList.contains('selected');
      out.push({on, failureId:rec.failureId, hierarchy:rec.hierarchy, cost:rec.cost});
    });
    return out;
  }

  function costSplitFallback(){
    const blocks = $$('.tile,.card,.panel,[data-tile]');
    let text = "";
    for(const b of blocks){
      const s = T(b);
      if(/cost\s*split/i.test(s)){ text = s; break; }
    }
    if(!text) return null;
    function grab(label){
      const m = text.match(new RegExp(label+"[^0-9]*(\\d+(?:\\.\\d+)?)\\s*%","i"));
      return m ? Math.round(parseFloat(m[1])) : 0;
    }
    return {
      elimination: grab("(?:elimination|elm|elim)"),
      engineering: grab("(?:engineering|eng)"),
      substitution: grab("(?:substitution|sub)"),
      administrative: grab("(?:administrative|admin|adm)"),
      ppe: grab("\\bppe\\b")
    };
  }

  function computeIndependence(controls){
    const byF = new Map();
    for(const c of controls){
      if(!c.on || c.failureId==null) continue;
      const key = String(c.failureId);
      if(!byF.has(key)) byF.set(key, new Set());
      byF.get(key).add(c.hierarchy);
    }
    const maxLayers=5;
    if(byF.size===0) return {pct:0, explain:"No active controls"};
    let sum=0;
    for(const L of byF.values()) sum += Math.min(L.size, maxLayers)/maxLayers;
    const pct = Math.round((sum/byF.size)*100);
    const avgLayers = (sum/byF.size*maxLayers).toFixed(1);
    return {pct, explain:`${byF.size} failures with controls; avg unique layers/failure: ${avgLayers}`};
  }

  function computeBudgetMix(controls){
    const on = controls.filter(c=>c.on);
    let total = on.reduce((a,c)=>a+(c.cost||0),0);
    const keys = ['elimination','engineering','substitution','administrative','ppe','unknown'];
    const by = Object.fromEntries(keys.map(k=>[k,0]));
    on.forEach(c=> by[(c.hierarchy in by)? c.hierarchy : 'unknown'] += (c.cost||0));
    if(total<=0){
      const fb = costSplitFallback();
      if(fb){
        return { total: 0, pct: fb, fallback:true };
      }
    }
    const toPct=(v)=> total>0? Math.round(v/total*100) : 0;
    return { total, pct: Object.fromEntries(keys.map(k=>[k,toPct(by[k])])) };
  }

  function getCRR(){
    let v = N(T($('#crrBig'))); if(v!=null) return v;
    const s = $$('.tile,.card,[data-tile]').map(n=>T(n)).join(' ');
    const m = s.match(/CRR[^0-9\-]*(-?\d+(?:\.\d+)?)\s*%/i);
    return m? parseFloat(m[1]) : null;
  }
  function getROI(){ let v = N(T($('#fin-roi'))); return v; }
  function getNPV(){ let v = N(T($('#fin-npv'))); return v; }

  function recomputeAssist(){
  // === Hysteresis state to prevent flapping of Next Step ===
  if (!window.__assistState) {
    window.__assistState = {
      last: {crr:null, roi:null, npvSign:null, covered:null, total:null, indepBucket:null, text:""},
      lockUntil: 0
    };
  }
  const nowTs = Date.now();
  const s = window.__assistState;

  // Helper: bucket independence (coarse) to avoid tiny fluctuations triggering flips
  function indepBucket(pct){
    if (pct==null) return 'n/a';
    if (pct >= 70) return 'high';
    if (pct >= 45) return 'mid';
    return 'low';
  }

    const ctrls = activeControls();
    const indep = computeIndependence(ctrls);
    const mix = computeBudgetMix(ctrls);
    const indepTone = indep.pct>=60 ? 'good' : (indep.pct>=35 ? 'warn' : 'bad');
    const indepEl = $('#independenceText'); if(indepEl) indepEl.innerHTML = `<span class="${indepTone}">${indep.pct}%</span> <span class="mini">(${indep.explain})</span>`;
    const bm = mix.pct; const bEl = $('#budgetText');
    if(bEl) bEl.innerHTML = `ELM ${bm.elimination||0}% • ENG ${bm.engineering||0}% • SUB ${bm.substitution||0}% • ADM ${bm.administrative||0}% • PPE ${bm.ppe||0}% <span class="mini">${mix.fallback?'(from Cost Split)':'(Total $'+(mix.total||0).toLocaleString()+')'}</span>`;

    // Prescriptive next steps
    const crr = getCRR(), roi = getROI(), npv = getNPV();
    const crrTarget = (function(){ let el=$('#crrTargetKnob,.crr-target-chip,[data-knob="crr_target"]'); return el? N(T(el))||80:80; })();
    let next = "";
    // Coverage check
    const byF = new Map();
    ctrls.forEach(c=>{ if(!byF.has(c.failureId)) byF.set(c.failureId, {on:new Set(), any:false}); byF.get(c.failureId).any=true; if(c.on) byF.get(c.failureId).on.add(c.hierarchy); });
    const allF = [...byF.keys()], covered = allF.filter(fid=> byF.get(fid).on.size>0), uncovered = allF.filter(fid=> byF.get(fid).on.size===0);
    if(allF.length && uncovered.length){
      next = `Cover gaps: add ≥1 control to ${uncovered.length} uncovered failure(s) (e.g., ${uncovered.slice(0,3).join(', ')}).`;
    } else if (crr!=null && crr < crrTarget){
      // Suggest the highest missing tier on a failure with least layers
      let target=null, missing=null;
      for(const fid of allF){
        const have = byF.get(fid).on;
        for(const tier of TIER_ORDER){ if(!have.has(tier)){ target=fid; missing=tier; break; } }
        if(target) break;
      }
      next = target? `Raise CRR: add ${missing} on failure ${target}; favor high SEI-per-$ options.` : `Raise CRR: add a higher-tier control on your riskiest failure.`;
    } else if (npv!=null && npv<0){
      next = `NPV negative: replace high-capex items with faster payback options and keep each failure covered.`;
    } else if (roi!=null && roi<0){
      next = `ROI negative: trim low SEI-per-$ controls and diversify tiers where duplicates exist.`;
    } else {
      next = `Portfolio balanced—maintain coverage, keep CRR ≥ target, and tune cost mix for ROI.`;
    }
    
    // --- Hysteresis: decide whether to update Next Step text ---
    const newState = {
      crr: crr==null? null : Math.round(crr),
      roi: roi==null? null : Math.round(roi),
      npvSign: (npv==null? null : (npv<0? -1: 1)),
      covered: covered.length,
      total: allF.length,
      indepBucket: indepBucket(indep.pct)
    };

    // compute diffs
    function changed(a,b){
      if(a==null && b==null) return false;
      if(a==null || b==null) return true;
      return Math.abs(a-b) >= 1; // 1% threshold for crr/roi
    }
    const materiallyChanged = (
      changed(newState.crr, s.last.crr) ||
      changed(newState.roi, s.last.roi) ||
      newState.npvSign != s.last.npvSign ||
      newState.covered != s.last.covered ||
      newState.total != s.last.total ||
      newState.indepBucket != s.last.indepBucket
    );

    // respect lock period to prevent flip-flop
    if (nowTs >= s.lockUntil and materiallyChanged) {
      // commit and lock for 2000ms
      const nEl=document.getElementById('nextStepText');
      if(nEl) nEl.textContent = next;
      const rEl=document.getElementById('recText');
      if(rEl) rEl.textContent = next;
      s.last = newState;
      s.last.text = next;
      s.lockUntil = nowTs + 2000;
    } else {
      // no material change: keep previous text (avoid DOM rewrite)
    }

  }

  // Boot
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=>{ buildRegistryOnce(); recomputeAssist(); // disabled polling (recomputeAssist) });
  } else {
    buildRegistryOnce(); recomputeAssist(); // disabled polling (recomputeAssist)
  }
  // Safety: also recompute on generic interactions
  ['click','input','change'].forEach(ev=>document.addEventListener(ev, recomputeAssist, true));
})();
</script>

<script>
// === Auto-detect Control Model toggle panel and apply black skin ===
(function(){
  function closestPanel(el){
    // walk up to a block-level container
    while (el && el.parentElement){
      if (el.classList){
        // candidate containers
        if (el.classList.contains('panel') || el.classList.contains('card') || el.classList.contains('section') ||
            el.classList.contains('table-container') || el.classList.contains('grid-block')) return el;
      }
      el = el.parentElement;
    }
    return null;
  }

  function markControlPanel(){
    const headerLabels = ["Failure","Control","Hierarchy","Cost Type","SEI","Unit Cost","Select"];
    const tables = document.querySelectorAll('table');
    for (const t of tables){
      const ths = Array.from(t.querySelectorAll('thead th')).map(x => x.textContent.trim());
      if (ths.length >= 5){
        // count matches
        const matches = headerLabels.reduce((acc, lbl)=> acc + (ths.some(x=> x.toLowerCase() === lbl.toLowerCase()) ? 1 : 0), 0);
        if (matches >= 5){
          const wrap = closestPanel(t) || t.parentElement;
          if (wrap && !wrap.classList.contains('cm-toggle-panel')){
            wrap.classList.add('cm-toggle-panel');
          }
        }
      }
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', markControlPanel);
  } else {
    markControlPanel();
  }
})();
</script>
</body>
</html>
